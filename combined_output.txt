# Arborescence du dépôt

  - .gitignore
  - LICENSE.md
  - README.md
  - generate_single_file.py
  - hacs.json
  - .github/
  - .git/
  - custom_components/
    - custom_components/ha_sunforecast_plus/
      - __init__.py
      - config_flow.py
      - const.py
      - constants.py
      - coordinator.py
      - diagnostics.py
      - energy.py
      - estimate.py
      - exceptions.py
      - manifest.json
      - models.py
      - open_meteo_solar_forecast.py
      - recorder.py
      - sensor.py
      - strings.json
      - custom_components/ha_sunforecast_plus/translations/
        - ar.json
        - bg.json
        - ca.json
        - cs.json
        - da.json
        - de.json
        - el.json
        - en-GB.json
        - en.json
        - es-419.json
        - es.json
        - et.json
        - fi.json
        - fr.json
        - gsw.json
        - he.json
        - hi.json
        - hu.json
        - id.json
        - it.json
        - ja.json
        - ko.json
        - lt.json
        - lv.json
        - nb.json
        - nl.json
        - pl.json
        - pt-BR.json
        - pt.json
        - ro.json
        - ru.json
        - sk.json
        - sl.json
        - sv.json
        - tr.json
        - uk.json
        - zh-Hans.json
        - zh-Hant.json

---


---
# .gitignore
---

/config
config2/*

tests/testing_config/deps
tests/testing_config/home-assistant.log*

# hass-release
data/
.token

# Translations
homeassistant/components/*/translations

# Hide sublime text stuff
*.sublime-project
*.sublime-workspace

# Hide some OS X stuff
.DS_Store
.AppleDouble
.LSOverride
Icon

# Thumbnails
._*

# IntelliJ IDEA
.idea
*.iml

# pytest
.pytest_cache
.cache

# GITHUB Proposed Python stuff:
*.py[cod]
__pycache__

# C extensions
*.so

# Packages
*.egg
*.egg-info
dist
build
eggs
.eggs
parts
bin
var
sdist
develop-eggs
.installed.cfg
lib
lib64
pip-wheel-metadata

# Logs
*.log
pip-log.txt

# Unit test / coverage reports
.coverage
coverage.xml
nosetests.xml
htmlcov/
test-reports/
test-results.xml
test-output.xml
pytest-*.txt

# Translations
*.mo

# Mr Developer
.mr.developer.cfg
.project
.pydevproject

.python-version

# emacs auto backups
*~
*#
*.orig

# venv stuff
pyvenv.cfg
pip-selfcheck.json
venv
.venv
Pipfile*
share/*
/Scripts/

# vimmy stuff
*.swp
*.swo
tags
ctags.tmp

# vagrant stuff
virtualization/vagrant/setup_done
virtualization/vagrant/.vagrant
virtualization/vagrant/config

# Visual Studio Code
.vscode/*
!.vscode/cSpell.json
!.vscode/extensions.json
!.vscode/tasks.json
.env

# Windows Explorer
desktop.ini
/home-assistant.pyproj
/home-assistant.sln
/.vs/*

# mypy
/.mypy_cache/*
/.dmypy.json

# Secrets
.lokalise_token

# monkeytype
monkeytype.sqlite3

# This is left behind by Azure Restore Cache
tmp_cache

# python-language-server / Rope
.ropeproject

# Will be created from script/split_tests.py
pytest_buckets.txt


---
# generate_single_file.py
---

import os

OUTPUT_FILE = "combined_output.txt"
IGNORED_DIRS = {".git", ".github", "__pycache__", "venv", "node_modules"}
IGNORED_CONTENT_EXTENSIONS = {".md"}  # <--- Exclure ces fichiers du contenu détaillé
IGNORED_BINARY_EXTENSIONS = {".png", ".jpg", ".jpeg", ".gif", ".exe", ".zip", ".tar", ".gz", ".7z"}

def should_ignore_dir(path):
    for ignored in IGNORED_DIRS:
        if f"/{ignored}/" in path.replace("\\", "/"):
            return True
    return False

def build_filetree():
    tree_lines = []
    for root, dirs, files in os.walk("."):
        if should_ignore_dir(root):
            continue
        indent = "  " * (root.count(os.sep))
        rel_root = os.path.relpath(root, ".")
        if rel_root != ".":
            tree_lines.append(f"{indent}- {rel_root}/")
        for file in sorted(files):
            full_path = os.path.join(root, file)
            if should_ignore_dir(full_path):
                continue
            tree_indent = "  " * (full_path.count(os.sep))
            tree_lines.append(f"{tree_indent}- {file}")
    return "\n".join(tree_lines)

def should_include_in_content(path):
    ext = os.path.splitext(path)[1].lower()
    if ext in IGNORED_BINARY_EXTENSIONS:
        return False
    if ext in IGNORED_CONTENT_EXTENSIONS:
        return False
    return True

def main():
    content_parts = []

    # 1. Filetree en tête
    filetree = build_filetree()
    content_parts.append("# Arborescence du dépôt\n\n")
    content_parts.append(filetree)
    content_parts.append("\n\n---\n")

    # 2. Contenu détaillé
    for root, dirs, files in os.walk("."):
        for file in sorted(files):
            full_path = os.path.join(root, file)
            if full_path.startswith("./" + OUTPUT_FILE):
                continue
            if should_ignore_dir(full_path):
                continue
            if not should_include_in_content(full_path):
                continue
            relative_path = os.path.relpath(full_path, ".")
            content_parts.append(f"\n\n---\n# {relative_path}\n---\n\n")
            try:
                with open(full_path, "r", encoding="utf-8") as f:
                    content = f.read()
                    content_parts.append(content)
            except Exception as e:
                content_parts.append(f"[Erreur de lecture: {e}]\n")

    combined_text = ''.join(content_parts)

    # 3. Estimation du nombre de tokens
    estimated_tokens = int(len(combined_text) / 4)
    combined_text += f"\n\n---\n# Estimation du nombre de tokens : {estimated_tokens} tokens\n"

    # 4. Sauvegarde
    with open(OUTPUT_FILE, "w", encoding="utf-8") as output:
        output.write(combined_text)

if __name__ == "__main__":
    main()


---
# hacs.json
---

{
    "name": "Sun Forecast Plus",
    "render_readme": true,
    "homeassistant": "2022.11",
    "zip_release": true,
    "filename": "sunforecast_plus.zip"
}


---
# custom_components/ha_sunforecast_plus/__init__.py
---

"""The Sunforecast Plus integration."""

from __future__ import annotations

from homeassistant.config_entries import ConfigEntry
from homeassistant.const import Platform
from homeassistant.core import HomeAssistant

from .const import DOMAIN
#from .exceptions import OpenMeteoSolarForecastUpdateFailed  # noqa: F401
from .coordinator import OpenMeteoSolarForecastDataUpdateCoordinator
#from .models import Estimate
#from .open_meteo_solar_forecast import OpenMeteoSolarForecast

__all__ = [
    "Estimate",
    "OpenMeteoSolarForecast"]

PLATFORMS = [Platform.SENSOR]


async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
    """Set up Forecast.Solar from a config entry."""
    coordinator = OpenMeteoSolarForecastDataUpdateCoordinator(hass, entry)
    await coordinator.async_config_entry_first_refresh()

    hass.data.setdefault(DOMAIN, {})[entry.entry_id] = coordinator

    await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)

    entry.async_on_unload(entry.add_update_listener(async_update_options))

    return True


async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
    """Unload a config entry."""
    unload_ok = await hass.config_entries.async_unload_platforms(entry, PLATFORMS)
    if unload_ok:
        hass.data[DOMAIN].pop(entry.entry_id)

    return unload_ok


async def async_update_options(hass: HomeAssistant, entry: ConfigEntry) -> None:
    """Update options."""
    await hass.config_entries.async_reload(entry.entry_id)


---
# custom_components/ha_sunforecast_plus/config_flow.py
---

"""Config flow for The Sunforecast Plus integration."""

from __future__ import annotations

from typing import Any

import voluptuous as vol
from homeassistant.config_entries import ConfigEntry, ConfigFlow, OptionsFlow
from homeassistant.const import CONF_API_KEY, CONF_LATITUDE, CONF_LONGITUDE, CONF_NAME
from homeassistant.core import callback
from homeassistant.helpers import config_validation as cv

from .const import (
    CONF_AZIMUTH,
    CONF_BASE_URL,
    CONF_DAMPING_EVENING,
    CONF_DAMPING_MORNING,
    CONF_DECLINATION,
    CONF_EFFICIENCY_FACTOR,
    CONF_INVERTER_POWER,
    CONF_MODEL,
    CONF_CLOUD_MODEL,
    CONF_CLOUD_CORRECTION_FACTOR,
    DEFAULT_CLOUD_CORRECTION_FACTOR,
    CONF_MODULES_POWER,
    DOMAIN,
)

try:
    from homeassistant.config_entries import ConfigFlowResult  # >=2024.4.0b0
except ImportError:
    from homeassistant.data_entry_flow import FlowResult as ConfigFlowResult


class OpenMeteoSolarForecastFlowHandler(ConfigFlow, domain=DOMAIN):
    """Handle a config flow for Open-Meteo Solar Forecast."""

    VERSION = 1

    @staticmethod
    @callback
    def async_get_options_flow(
        config_entry: ConfigEntry,
    ) -> OpenMeteoSolarForecastOptionFlowHandler:
        """Get the options flow for this handler."""
        return OpenMeteoSolarForecastOptionFlowHandler()

    async def async_step_user(
        self, user_input: dict[str, Any] | None = None
    ) -> ConfigFlowResult:
        """Handle a flow initiated by the user."""
        if user_input is not None:
            return self.async_create_entry(
                title=user_input[CONF_NAME],
                data={
                    CONF_LATITUDE: user_input[CONF_LATITUDE],
                    CONF_LONGITUDE: user_input[CONF_LONGITUDE],
                },
                options={
                    CONF_API_KEY: user_input[CONF_API_KEY],
                    CONF_AZIMUTH: user_input[CONF_AZIMUTH],
                    CONF_BASE_URL: user_input[CONF_BASE_URL],
                    CONF_DAMPING_MORNING: user_input[CONF_DAMPING_MORNING],
                    CONF_DAMPING_EVENING: user_input[CONF_DAMPING_EVENING],
                    CONF_DECLINATION: user_input[CONF_DECLINATION],
                    CONF_MODULES_POWER: user_input[CONF_MODULES_POWER],
                    CONF_INVERTER_POWER: user_input[CONF_INVERTER_POWER],
                    CONF_EFFICIENCY_FACTOR: user_input[CONF_EFFICIENCY_FACTOR],
                    CONF_MODEL: user_input[CONF_MODEL],
                    CONF_CLOUD_MODEL: user_input[CONF_CLOUD_MODEL], 
                    CONF_CLOUD_CORRECTION_FACTOR: user_input[CONF_CLOUD_CORRECTION_FACTOR], 

                },
            )

        return self.async_show_form(
            step_id="user",
            data_schema=vol.Schema(
                {
                    vol.Optional(CONF_API_KEY, default=""): str,
                    vol.Required(
                        CONF_BASE_URL, default="https://api.open-meteo.com"
                    ): str,
                    vol.Required(
                        CONF_NAME, default=self.hass.config.location_name
                    ): str,
                    vol.Required(
                        CONF_LATITUDE, default=self.hass.config.latitude
                    ): cv.latitude,
                    vol.Required(
                        CONF_LONGITUDE, default=self.hass.config.longitude
                    ): cv.longitude,
                    vol.Required(CONF_DECLINATION, default=25): vol.All(
                        vol.Coerce(int), vol.Range(min=0, max=90)
                    ),
                    vol.Required(CONF_AZIMUTH, default=180): vol.All(
                        vol.Coerce(int), vol.Range(min=0, max=360)
                    ),
                    vol.Required(CONF_MODULES_POWER): vol.All(
                        vol.Coerce(int), vol.Range(min=1)
                    ),
                    vol.Required(CONF_INVERTER_POWER, default=0): vol.All(
                        vol.Coerce(int), vol.Range(min=0)
                    ),
                    vol.Optional(CONF_DAMPING_MORNING, default=0.0): vol.Coerce(float),
                    vol.Optional(CONF_DAMPING_EVENING, default=0.0): vol.Coerce(float),
                    vol.Optional(CONF_EFFICIENCY_FACTOR, default=1.0): vol.All(
                        vol.Coerce(float), vol.Range(min=0)
                    ),
                    vol.Optional(CONF_MODEL, default="best_match"): str,
                    vol.Optional(CONF_CLOUD_MODEL, default="best_match"): str,
                    vol.Optional(CONF_CLOUD_CORRECTION_FACTOR, default=0.5
): vol.All(vol.Coerce(float), vol.Range(min=0, max=1)),
                }
            ),
        )


class OpenMeteoSolarForecastOptionFlowHandler(OptionsFlow):
    """Handle options."""

    async def async_step_init(
        self, user_input: dict[str, Any] | None = None
    ) -> ConfigFlowResult:
        """Manage the options."""
        errors = {}
        if user_input is not None:
            return self.async_create_entry(
                title="", data=user_input | {CONF_API_KEY: user_input.get(CONF_API_KEY)}
            )

        return self.async_show_form(
            step_id="init",
            data_schema=vol.Schema(
                {
                    vol.Optional(
                        CONF_API_KEY,
                        description={
                            "suggested_value": self.config_entry.options.get(
                                CONF_API_KEY, ""
                            )
                        },
                    ): str,
                    vol.Required(
                        CONF_BASE_URL,
                        default=self.config_entry.options[CONF_BASE_URL],
                    ): str,
                    vol.Required(
                        CONF_DECLINATION,
                        default=self.config_entry.options[CONF_DECLINATION],
                    ): vol.All(vol.Coerce(int), vol.Range(min=0, max=90)),
                    vol.Required(
                        CONF_AZIMUTH,
                        default=self.config_entry.options.get(CONF_AZIMUTH),
                    ): vol.All(vol.Coerce(int), vol.Range(min=-0, max=360)),
                    vol.Required(
                        CONF_MODULES_POWER,
                        default=self.config_entry.options[CONF_MODULES_POWER],
                    ): vol.All(vol.Coerce(int), vol.Range(min=1)),
                    vol.Optional(
                        CONF_DAMPING_MORNING,
                        default=self.config_entry.options.get(
                            CONF_DAMPING_MORNING, 0.0
                        ),
                    ): vol.Coerce(float),
                    vol.Optional(
                        CONF_DAMPING_EVENING,
                        default=self.config_entry.options.get(
                            CONF_DAMPING_EVENING, 0.0
                        ),
                    ): vol.Coerce(float),
                    vol.Required(
                        CONF_INVERTER_POWER,
                        default=self.config_entry.options.get(CONF_INVERTER_POWER, 0),
                    ): vol.All(vol.Coerce(int), vol.Range(min=0)),
                    vol.Optional(
                        CONF_EFFICIENCY_FACTOR,
                        default=self.config_entry.options.get(
                            CONF_EFFICIENCY_FACTOR, 1.0
                        ),
                    ): vol.All(vol.Coerce(float), vol.Range(min=0)),
                    vol.Optional(
                        CONF_MODEL,
                        default=self.config_entry.options.get(CONF_MODEL, "best_match"),
                    ): str,
                    vol.Optional(
                        CONF_CLOUD_MODEL,
                        default=self.config_entry.options.get(CONF_CLOUD_MODEL, "best_match"),
                    ): str,
                    vol.Optional(
                        CONF_CLOUD_CORRECTION_FACTOR,
                        default=self.config_entry.options.get(
                            CONF_CLOUD_CORRECTION_FACTOR, DEFAULT_CLOUD_CORRECTION_FACTOR
                        ),
                    ): vol.All(vol.Coerce(float), vol.Range(min=0, max=1)),
                }
            ),
            errors=errors,
        )


---
# custom_components/ha_sunforecast_plus/const.py
---

"""Constants for the Open-Meteo Solar Forecast integration."""

from __future__ import annotations

import logging

DOMAIN = "ha_sunforecast_plus"
LOGGER = logging.getLogger(__package__)

CONF_BASE_URL = "base_url"
CONF_DECLINATION = "declination"
CONF_AZIMUTH = "azimuth"
CONF_MODULES_POWER = "modules_power"
CONF_DAMPING_MORNING = "damping_morning"
CONF_DAMPING_EVENING = "damping_evening"
CONF_INVERTER_POWER = "inverter_power"
CONF_EFFICIENCY_FACTOR = "efficiency_factor"
CONF_MODEL = "model"
CONF_CLOUD_MODEL ="cloud_model"
CONF_CLOUD_CORRECTION_FACTOR = "cloud_correction_factor"
DEFAULT_CLOUD_CORRECTION_FACTOR = 0.5

ATTR_WATTS = "watts"
ATTR_WH_PERIOD = "wh_period"


---
# custom_components/ha_sunforecast_plus/constants.py
---

"""Constants for the solar forecast module."""

from dataclasses import dataclass

# STC specifies a cell temperature of 25°C and an irradiance of 1000 W/m².
# The temperature coefficient of most solar panels is 0.004°C⁻¹.
# Source: https://www.researchgate.net/publication/372240079_Solar_Prediction_Strategy_for_Managing_Virtual_Power_Stations


ALPHA_TEMP = -0.004  # °C-1
G_STC = 1000.0  # W/m2
TEMP_STC_CELL = 25.0  # °C


# Ross Model Constants
#
# Source: https://www.researchgate.net/publication/275438802_Thermal_effects_of_the_extended_holographic_regions_for_holographic_planar_concentrator
@dataclass
class RossModelConstants:
    """Constants for the Ross model."""

    WELL_COOLED = 0.0200
    FREE_STANDING = 0.0208
    FLAT_ON_ROOF = 0.0260
    NOT_SO_WELL_COOLED = 0.0342
    TRANSPARENT_PV = 0.0455
    FACADE_INTEGRATED = 0.0538
    ON_SLOPED_ROOF = 0.0563


---
# custom_components/ha_sunforecast_plus/coordinator.py
---

"""DataUpdateCoordinator for the Sunforecast Plus integration."""
from __future__ import annotations
from datetime import timedelta, datetime, timezone
from homeassistant.config_entries import ConfigEntry
from homeassistant.const import CONF_API_KEY, CONF_LATITUDE, CONF_LONGITUDE
from homeassistant.core import HomeAssistant
from homeassistant.helpers.aiohttp_client import async_get_clientsession
from homeassistant.helpers.update_coordinator import DataUpdateCoordinator
from .open_meteo_solar_forecast import Estimate, OpenMeteoSolarForecast

from .const import (
    CONF_AZIMUTH,
    CONF_BASE_URL,
    CONF_DAMPING_EVENING,
    CONF_DAMPING_MORNING,
    CONF_DECLINATION,
    CONF_EFFICIENCY_FACTOR,
    CONF_INVERTER_POWER,
    CONF_MODULES_POWER,
    CONF_MODEL,
    DOMAIN,
    LOGGER,
)
from .exceptions import OpenMeteoSolarForecastUpdateFailed

def clean_value(value):
    """Remove brackets and convert to float, then return as string."""
    if isinstance(value, str):
        value = value.strip('[]')
    cleaned_value = round(float(value), 2)
    LOGGER.debug("Cleaned value: %s", cleaned_value)
    return str(cleaned_value)

class OpenMeteoSolarForecastDataUpdateCoordinator(DataUpdateCoordinator[Estimate]):
    """The Solar Forecast Data Update Coordinator."""
    config_entry: ConfigEntry

    def __init__(self, hass: HomeAssistant, entry: ConfigEntry) -> None:
        """Initialize the Solar Forecast coordinator."""
        self.config_entry = entry
        self.daily_forecasts = {}  # Dictionnaire pour stocker les prévisions journalières

        # Our option flow may cause it to be an empty string,
        # this if statement is here to catch that.
        api_key = entry.options.get(CONF_API_KEY) or None

        # Handle new options that were added after the initial release
        ac_kwp = entry.options.get(CONF_INVERTER_POWER, 0)
        ac_kwp = ac_kwp / 1000 if ac_kwp else None

        # Ensure latitude and longitude are valid numbers
        latitude = clean_value(entry.data[CONF_LATITUDE])
        longitude = clean_value(entry.data[CONF_LONGITUDE])
        if not (-90 <= float(latitude) <= 90) or not (-180 <= float(longitude) <= 180):
            raise ValueError("Invalid latitude or longitude values")

        self.forecast = OpenMeteoSolarForecast(
            api_key=api_key,
            session=async_get_clientsession(hass),
            latitude=float(latitude),
            longitude=float(longitude),
            azimuth=entry.options[CONF_AZIMUTH] - 180,
            base_url=entry.options[CONF_BASE_URL],
            ac_kwp=ac_kwp,
            dc_kwp=(entry.options[CONF_MODULES_POWER] / 1000),
            declination=entry.options[CONF_DECLINATION],
            efficiency_factor=entry.options[CONF_EFFICIENCY_FACTOR],
            damping_morning=entry.options.get(CONF_DAMPING_MORNING, 0.0),
            damping_evening=entry.options.get(CONF_DAMPING_EVENING, 0.0),
            weather_model=entry.options.get(CONF_MODEL, "best_match"),
            config_entry=entry,
        )

        # Initialiser les attributs pour le débogage
        self.cloud_cover_data = []
        self.original_values = {}
        self.adjustment_stats = {}

        update_interval = timedelta(minutes=30)

        super().__init__(hass, LOGGER, name=DOMAIN, update_interval=update_interval)

    async def _async_update_data(self) -> Estimate:
        """Fetch Open-Meteo Solar Forecast estimates."""
        try:
            estimate = await self.forecast.estimate()
            
            for day in estimate.wh_days:
                date_str = day.isoformat()
                self.daily_forecasts[date_str] = estimate.wh_days[day]
            return estimate
        
        except Exception as error:
            LOGGER.error("Error fetching data: %s", error)
            raise OpenMeteoSolarForecastUpdateFailed(f"Error fetching data: {error}") from error


---
# custom_components/ha_sunforecast_plus/diagnostics.py
---

"""Diagnostics support for The Sunforecast Plus integration."""

from __future__ import annotations

from typing import Any

from open_meteo_solar_forecast import Estimate

from homeassistant.components.diagnostics import async_redact_data
from homeassistant.config_entries import ConfigEntry
from homeassistant.const import CONF_API_KEY, CONF_LATITUDE, CONF_LONGITUDE
from homeassistant.core import HomeAssistant
from homeassistant.helpers.update_coordinator import DataUpdateCoordinator

from .const import DOMAIN

TO_REDACT = {
    CONF_API_KEY,
    CONF_LATITUDE,
    CONF_LONGITUDE,
}


async def async_get_config_entry_diagnostics(
    hass: HomeAssistant, entry: ConfigEntry
) -> dict[str, Any]:
    """Return diagnostics for a config entry."""
    coordinator: DataUpdateCoordinator[Estimate] = hass.data[DOMAIN][entry.entry_id]

    return {
        "entry": {
            "title": entry.title,
            "data": async_redact_data(entry.data, TO_REDACT),
            "options": async_redact_data(entry.options, TO_REDACT),
        },
        "data": {
            "energy_production_today": coordinator.data.energy_production_today,
            "energy_production_today_remaining": coordinator.data.energy_production_today_remaining,
            "energy_production_tomorrow": coordinator.data.energy_production_tomorrow,
            "energy_current_hour": coordinator.data.energy_current_hour,
            "power_production_now": coordinator.data.power_production_now,
            "watts": {
                watt_datetime.isoformat(): watt_value
                for watt_datetime, watt_value in coordinator.data.watts.items()
            },
            "wh_days": {
                wh_datetime.isoformat(): wh_value
                for wh_datetime, wh_value in coordinator.data.wh_days.items()
            },
            "wh_period": {
                wh_datetime.isoformat(): wh_value
                for wh_datetime, wh_value in coordinator.data.wh_period.items()
            },
        },
        "account": {
            "timezone": coordinator.data.timezone,
        },
    }


---
# custom_components/ha_sunforecast_plus/energy.py
---

"""Energy platform."""

from __future__ import annotations

from homeassistant.core import HomeAssistant

from .const import DOMAIN


async def async_get_solar_forecast(
    hass: HomeAssistant, config_entry_id: str
) -> dict[str, dict[str, float | int]] | None:
    """Get solar forecast for a config entry ID."""
    if (coordinator := hass.data[DOMAIN].get(config_entry_id)) is None:
        return None

    return {
        "wh_hours": {
            timestamp.isoformat(): val
            for timestamp, val in coordinator.data.wh_period.items()
        }
    }


---
# custom_components/ha_sunforecast_plus/estimate.py
---

"""Data models for the Forecast.Solar API."""

from __future__ import annotations

import datetime as dt
from dataclasses import dataclass


def _timed_value(at: dt.datetime, data: dict[dt.datetime, int]) -> int | None:
    """Return the value for a specific time."""
    value = None
    for timestamp, cur_value in data.items():
        if timestamp > at:
            return value
        value = cur_value

    return None


def _interval_value_sum(
    interval_begin: dt.datetime, interval_end: dt.datetime, data: dict[dt.datetime, int]
) -> int:
    """Return the sum of values in interval."""
    total = 0

    for timestamp, wh in data.items():
        # Skip all until this hour
        if timestamp < interval_begin:
            continue

        if timestamp >= interval_end:
            break

        total += wh

    return total


def _interval_value_sum_w_to_wh(
    interval_begin: dt.datetime, interval_end: dt.datetime, data: dict[dt.datetime, int]
) -> int:
    """Convert W to Wh and return the sum of values in interval."""
    total = 0
    sorted_timestamps = sorted(data.keys())

    for i, timestamp in enumerate(sorted_timestamps):
        # Skip all until this hour
        if timestamp < interval_begin:
            continue

        if timestamp >= interval_end:
            break

        # Calculate the time difference to the next timestamp or interval_end
        next_timestamp = (
            sorted_timestamps[i + 1] if i + 1 < len(sorted_timestamps) else interval_end
        )
        if next_timestamp > interval_end:
            next_timestamp = interval_end

        # Calculate the duration in hours
        duration_hours = (next_timestamp - timestamp).total_seconds() / 3600

        # Add the energy in watt-hours
        total += data[timestamp] * duration_hours

    return total


@dataclass
class Estimate:
    """Object holding estimate forecast results from Forecast.Solar.

    Attributes
    ----------
        watts: Estimated solar power output per time period.
        wh_period: Estimated solar energy production differences per hour.
        wh_days: Estimated solar energy production per day.

    """

    watts: dict[dt.datetime, int]
    wh_period: dict[dt.datetime, int]
    wh_days: dict[dt.datetime, int]
    api_timezone: dt.timezone

    @property
    def timezone(self) -> timezone:
        """Return API timezone information."""
        return self.api_timezone

    @property
    def energy_production_today(self) -> int:
        """Return estimated energy produced today."""
        return self.day_production(self.now().date())

    @property
    def energy_production_tomorrow(self) -> int:
        """Return estimated energy produced today."""
        return self.day_production(self.now().date() + dt.timedelta(days=1))

    @property
    def energy_production_today_remaining(self) -> int:
        """Return estimated energy produced in rest of today."""
        return _interval_value_sum_w_to_wh(
            self.now(),
            self.now().replace(hour=0, minute=0, second=0, microsecond=0)
            + dt.timedelta(days=1),
            self.watts,
        )

    @property
    def power_production_now(self) -> int:
        """Return estimated power production right now."""
        return self.power_production_at_time(self.now())

    @property
    def power_highest_peak_time_today(self) -> dt.datetime:
        """Return datetime with highest power production moment today."""
        return self.peak_production_time(self.now().date())

    @property
    def power_highest_peak_time_tomorrow(self) -> dt.datetime:
        """Return datetime with highest power production moment tomorrow."""
        return self.peak_production_time(self.now().date() + dt.timedelta(days=1))

    @property
    def energy_current_hour(self) -> int:
        """Return the estimated energy production for the current hour."""
        return _interval_value_sum(
            self.now().replace(minute=0, second=0, microsecond=0),
            self.now().replace(minute=0, second=0, microsecond=0)
            + dt.timedelta(hours=1),
            self.wh_period,
        )

    def day_production(self, specific_date: dt.date) -> int:
        """Return the day production."""
        for date, production in self.wh_days.items():
            if date == specific_date:
                return production

        return 0

    def now(self) -> dt.datetime:
        """Return the current timestamp in the API timezone."""
        return dt.datetime.now(tz=self.api_timezone)

    def peak_production_time(self, specific_date: dt.date) -> dt.datetime:
        """Return the peak time on a specific date."""
        value = max(
            (watt for date, watt in self.watts.items() if date.date() == specific_date),
            default=None,
        )
        for timestamp, watt in self.watts.items():
            if watt == value and timestamp.date() == specific_date:
                return timestamp
        raise RuntimeError("No peak production time found")

    def power_production_at_time(self, time: dt.datetime) -> int:
        """Return estimated power production at a specific time."""
        return _timed_value(time, self.watts) or 0

    def sum_energy_production(self, period_hours: int) -> int:
        """Return the sum of the energy production."""
        now = self.now().replace(minute=59, second=59, microsecond=999)
        until = now + dt.timedelta(hours=period_hours)

        return _interval_value_sum(now, until, self.wh_period)


---
# custom_components/ha_sunforecast_plus/exceptions.py
---

class OpenMeteoSolarForecastUpdateFailed(Exception):
    """Custom exception to handle update failures."""

class OpenMeteoSolarForecastError(Exception):
    """Generic OpenMeteoSolarForecast exception."""


class OpenMeteoSolarForecastConnectionError(OpenMeteoSolarForecastError):
    """OpenMeteoSolarForecast connection exception."""


class OpenMeteoSolarForecastConfigError(OpenMeteoSolarForecastError):
    """OpenMeteoSolarForecast configuration exception."""


class OpenMeteoSolarForecastAuthenticationError(OpenMeteoSolarForecastError):
    """OpenMeteoSolarForecast authentication exception."""


class OpenMeteoSolarForecastRequestError(OpenMeteoSolarForecastError):
    """OpenMeteoSolarForecast request exception."""


class OpenMeteoSolarForecastRatelimitError(OpenMeteoSolarForecastRequestError):
    """OpenMeteoSolarForecast rate limit exception."""


class OpenMeteoSolarForecastInvalidModel(OpenMeteoSolarForecastError):
    """OpenMeteoSolarForecast invalid model exception."""

---
# custom_components/ha_sunforecast_plus/manifest.json
---

{
  "domain": "ha_sunforecast_plus",
  "name": "SunForecast Plus",
  "codeowners": ["@chourmovs"],
  "config_flow": true,
  "documentation": "https://github.com/chourmovs/ha-sunforecast-plus",
  "integration_type": "service",
  "iot_class": "cloud_polling",
  "issue_tracker": "https://github.com/chourmovs/ha-sunforecast-plus/issues",
  "version": "0.38"
}


---
# custom_components/ha_sunforecast_plus/models.py
---

"""Data models for the Forecast.Solar API."""

from __future__ import annotations

import datetime as dt
from dataclasses import dataclass


def _timed_value(at: dt.datetime, data: dict[dt.datetime, int]) -> int | None:
    """Return the value for a specific time."""
    value = None
    for timestamp, cur_value in data.items():
        if timestamp > at:
            return value
        value = cur_value

    return None


def _interval_value_sum(
    interval_begin: dt.datetime, interval_end: dt.datetime, data: dict[dt.datetime, int]
) -> int:
    """Return the sum of values in interval."""
    total = 0

    for timestamp, wh in data.items():
        # Skip all until this hour
        if timestamp < interval_begin:
            continue

        if timestamp >= interval_end:
            break

        total += wh

    return total


def _interval_value_sum_w_to_wh(
    interval_begin: dt.datetime, interval_end: dt.datetime, data: dict[dt.datetime, int]
) -> int:
    """Convert W to Wh and return the sum of values in interval."""
    total = 0
    sorted_timestamps = sorted(data.keys())

    for i, timestamp in enumerate(sorted_timestamps):
        # Skip all until this hour
        if timestamp < interval_begin:
            continue

        if timestamp >= interval_end:
            break

        # Calculate the time difference to the next timestamp or interval_end
        next_timestamp = (
            sorted_timestamps[i + 1] if i + 1 < len(sorted_timestamps) else interval_end
        )
        if next_timestamp > interval_end:
            next_timestamp = interval_end

        # Calculate the duration in hours
        duration_hours = (next_timestamp - timestamp).total_seconds() / 3600

        # Add the energy in watt-hours
        total += data[timestamp] * duration_hours

    return total


@dataclass
class Estimate:
    """Object holding estimate forecast results from Forecast.Solar.

    Attributes
    ----------
        watts: Estimated solar power output per time period.
        wh_period: Estimated solar energy production differences per hour.
        wh_days: Estimated solar energy production per day.

    """

    watts: dict[dt.datetime, int]
    wh_period: dict[dt.datetime, int]
    wh_days: dict[dt.datetime, int]
    api_timezone: dt.timezone

    @property
    def timezone(self) -> timezone:
        """Return API timezone information."""
        return self.api_timezone

    @property
    def energy_production_today(self) -> int:
        """Return estimated energy produced today."""
        return self.day_production(self.now().date())

    @property
    def energy_production_tomorrow(self) -> int:
        """Return estimated energy produced today."""
        return self.day_production(self.now().date() + dt.timedelta(days=1))

    @property
    def energy_production_today_remaining(self) -> int:
        """Return estimated energy produced in rest of today."""
        return _interval_value_sum_w_to_wh(
            self.now(),
            self.now().replace(hour=0, minute=0, second=0, microsecond=0)
            + dt.timedelta(days=1),
            self.watts,
        )

    @property
    def power_production_now(self) -> int:
        """Return estimated power production right now."""
        return self.power_production_at_time(self.now())

    @property
    def power_highest_peak_time_today(self) -> dt.datetime:
        """Return datetime with highest power production moment today."""
        return self.peak_production_time(self.now().date())

    @property
    def power_highest_peak_time_tomorrow(self) -> dt.datetime:
        """Return datetime with highest power production moment tomorrow."""
        return self.peak_production_time(self.now().date() + dt.timedelta(days=1))

    @property
    def energy_current_hour(self) -> int:
        """Return the estimated energy production for the current hour."""
        return _interval_value_sum(
            self.now().replace(minute=0, second=0, microsecond=0),
            self.now().replace(minute=0, second=0, microsecond=0)
            + dt.timedelta(hours=1),
            self.wh_period,
        )

    def day_production(self, specific_date: dt.date) -> int:
        """Return the day production."""
        for date, production in self.wh_days.items():
            if date == specific_date:
                return production

        return 0

    def now(self) -> dt.datetime:
        """Return the current timestamp in the API timezone."""
        return dt.datetime.now(tz=self.api_timezone)

    def peak_production_time(self, specific_date: dt.date) -> dt.datetime:
        """Return the peak time on a specific date."""
        value = max(
            (watt for date, watt in self.watts.items() if date.date() == specific_date),
            default=None,
        )
        for timestamp, watt in self.watts.items():
            if watt == value and timestamp.date() == specific_date:
                return timestamp
        raise RuntimeError("No peak production time found")

    def power_production_at_time(self, time: dt.datetime) -> int:
        """Return estimated power production at a specific time."""
        return _timed_value(time, self.watts) or 0

    def sum_energy_production(self, period_hours: int) -> int:
        """Return the sum of the energy production."""
        now = self.now().replace(minute=59, second=59, microsecond=999)
        until = now + dt.timedelta(hours=period_hours)

        return _interval_value_sum(now, until, self.wh_period)


---
# custom_components/ha_sunforecast_plus/open_meteo_solar_forecast.py
---

"""Asynchronous Python client for the API."""

from __future__ import annotations

from datetime import timedelta, datetime, timezone
from collections import defaultdict
from dataclasses import dataclass
from datetime import datetime as dt
from datetime import timedelta, timezone
from typing import Any, Self

from aiohttp import ClientSession

from .constants import ALPHA_TEMP, G_STC, TEMP_STC_CELL, RossModelConstants
from .exceptions import (
    OpenMeteoSolarForecastAuthenticationError,
    OpenMeteoSolarForecastConfigError,
    OpenMeteoSolarForecastConnectionError,
    OpenMeteoSolarForecastError,
    OpenMeteoSolarForecastInvalidModel,
    OpenMeteoSolarForecastRatelimitError,
    OpenMeteoSolarForecastRequestError,
)
from .models import Estimate
from homeassistant.config_entries import ConfigEntry

from .const import (

    CONF_CLOUD_CORRECTION_FACTOR,
    DEFAULT_CLOUD_CORRECTION_FACTOR,
    LOGGER,
)


@dataclass
class OpenMeteoSolarForecast:
    """Main class for handling connections with the API."""

    azimuth: float | list[float]
    declination: float | list[float]
    dc_kwp: float | list[float]
    latitude: float | list[float]
    longitude: float | list[float]
    config_entry: ConfigEntry


    past_days: int = 92
    forecast_days: int = 16

    ac_kwp: float | None = None
    api_key: str | None = None
    base_url: str | None = None
    weather_model: str | None = None
    damping_morning: float | list[float] = 0.0
    damping_evening: float | list[float] = 0.0
    efficiency_factor: float | list[float] = 1.0
    
    session: ClientSession | None = None
    _close_session: bool = False

    def __post_init__(self) -> None:
        """Initialize the OpenMeteoSolarForecast object."""
        if self.base_url is None:
            self.base_url = "https://api.open-meteo.com"
        if self.ac_kwp is None:
            self.ac_kwp = float("inf")

        # Validate list parameters
        if list in map(
            type,
            (
                self.azimuth,
                self.declination,
                self.dc_kwp,
                self.latitude,
                self.longitude,
            ),
        ):
            if not all(
                isinstance(param, list) and len(param) == len(self.dc_kwp)
                for param in (
                    self.azimuth,
                    self.declination,
                    self.dc_kwp,
                    self.latitude,
                    self.longitude,
                )
            ):
                raise OpenMeteoSolarForecastConfigError(
                    "The parameters must be of the same length"
                )
        else:
            self.azimuth = [self.azimuth]
            self.declination = [self.declination]
            self.dc_kwp = [self.dc_kwp]
            self.latitude = [self.latitude]
            self.longitude = [self.longitude]

        def test_param_len(attr_name: str, other_attr: list[Any]) -> list[Any]:
            """Validate the length of a param and return a list of the same length."""
            attr = getattr(self, attr_name)
            if isinstance(attr, list):
                if len(attr) != len(other_attr):
                    msg = f"{attr_name} must be the same length as the other parameters"
                    raise OpenMeteoSolarForecastConfigError(msg)
            else:
                attr = [attr] * len(other_attr)
            return attr

        self.efficiency_factor = test_param_len("efficiency_factor", self.dc_kwp)
        self.damping_morning = test_param_len("damping_morning", self.dc_kwp)
        self.damping_evening = test_param_len("damping_evening", self.dc_kwp)

    async def _request(
        self,
        uri: str,
        *,
        params: dict[str, Any] | None = None,
    ) -> Any:
        """Handle a request to the API.

        A generic method for sending/handling HTTP requests done against the API.

        Args:
        ----
            uri: Request URI, for example, '/v1/forecast'.

        Returns:
        -------
            A Python dictionary (JSON decoded) with the response from the API.

        Raises:
        ------
            OpenMeteoSolarForecastAuthenticationError: If the API key is invalid.
            OpenMeteoSolarForecastConnectionError: An error occurred while communicating
                with the API.
            OpenMeteoSolarForecastError: Received an unexpected response from the API.
            OpenMeteoSolarForecastRequestError: There is something wrong with the
                variables used in the request.
            OpenMeteoSolarForecastRatelimitError: The number of requests has exceeded
                the rate limit of the API.

        """
        # Connect as normal
        if self.session is None:
            self.session = ClientSession()
            self._close_session = True

        # Add the API key to the request
        if self.api_key:
            params = params or {}
            params["apikey"] = self.api_key

        # Add the weather model to the request
        if self.weather_model:
            if "," in self.weather_model:
                raise OpenMeteoSolarForecastInvalidModel(
                    "Multiple models are not supported"
                )
            params = params or {}
            params["models"] = self.weather_model

        # Get response from the API
        response = await self.session.request(
            "GET",
            self.base_url + uri,
            params=params,
        )

        if response.status in (502, 503):
            raise OpenMeteoSolarForecastConnectionError("The API is unreachable")

        if response.status == 400:
            raise OpenMeteoSolarForecastRequestError("Bad request")

        if response.status in (401, 403):
            raise OpenMeteoSolarForecastAuthenticationError("Invalid API key")

        if response.status == 422:
            raise OpenMeteoSolarForecastConfigError("Invalid configuration")

        if response.status == 429:
            raise OpenMeteoSolarForecastRatelimitError("Rate limit exceeded")

        response.raise_for_status()

        content_type = response.headers.get("Content-Type", "")
        if "application/json" not in content_type:
            text = await response.text()
            raise OpenMeteoSolarForecastError(
                "Unexpected response from the API",
                {"Content-Type": content_type, "response": text},
            )

        return await response.json()

    async def _fetch_hourly_cloud_cover(self) -> list:
            """Fetch hourly cloud cover data from open-meteo.com."""
            # Cette méthode est similaire à celle dans coordinator.py
            latitude = str(self.latitude[0])  # Utilisation du premier élément de la liste
            longitude = str(self.longitude[0])  # Utilisation du premier élément de la liste
            cloud_cover_model = self.weather_model  # Utilisation de weather_model
            LOGGER.debug("Fetching cloud cover data for latitude: %s, longitude: %s", latitude, longitude)
            
            url = f"https://api.open-meteo.com/v1/forecast?latitude={latitude}&longitude={longitude}&hourly=cloud_cover&timeformat=iso8601&timezone=auto&models={cloud_cover_model}&forecast_days=7"
            LOGGER.debug("Fetching cloud cover data from URL: %s", url)
            
            async with self.session.get(url) as response:
                if response.status != 200:
                    response_text = await response.text()
                    LOGGER.error("Failed to fetch cloud cover data: %s. Response: %s", response.status, response_text)
                    raise Exception(f"Failed to fetch cloud cover data: {response.status}")
                
                data = await response.json()
                cloud_cover_data = data.get("hourly", {}).get("cloud_cover", [])
                return cloud_cover_data
            
    async def _adjust_estimate_with_cloud_cover(self, estimate: Estimate, cloud_cover_data: list) -> None:
        """Ajuster l'estimation solaire en fonction des données de nébulosité."""
        # Logique de correction, similaire à celle dans coordinator.py mais adaptée
        if not cloud_cover_data:
            LOGGER.warning("No cloud cover data available for adjustment")
            return
        
        # Récupérer la liste des timestamps des données de nébulosité depuis l'API
        cloud_timestamps = []
        try:
            url = f"https://api.open-meteo.com/v1/forecast?latitude={str(self.latitude[0])}&longitude={str(self.longitude[0])}&hourly=time&timeformat=iso8601&timezone=auto&models={self.weather_model}&forecast_days=7"
            async with self.session.get(url) as response:
                if response.status != 200:
                    response_text = await response.text()
                    LOGGER.error("Failed to fetch cloud timestamps: %s. Response: %s", response.status, response_text)
                    raise Exception(f"Failed to fetch cloud timestamps: {response.status}")
                
                data = await response.json()
                cloud_timestamps = data.get("hourly", {}).get("time", [])
        except Exception as e:
            LOGGER.error("Error fetching cloud timestamps: %s", e)
         # Sauvegarder les valeurs originales avant ajustement pour comparaison
        self.original_values = {
            "watts": {str(k): v for k, v in estimate.watts.items()},
            "wh_period": {str(k): v for k, v in estimate.wh_period.items()},
            "wh_days": {str(k): v for k, v in estimate.wh_days.items()},
            "power_production_now": estimate.power_production_now,
            "energy_production_today": estimate.energy_production_today,
            "energy_production_tomorrow": estimate.energy_production_tomorrow
        }
        
        # Somme totale avant ajustement pour calculer le pourcentage
        total_energy_before = sum(estimate.wh_period.values())
        
        # Convertir les timestamps cloud en dictionnaire pour faciliter la recherche
        cloud_cover_dict = {}
        if cloud_timestamps:
            for i, timestamp_str in enumerate(cloud_timestamps):
                if i < len(cloud_cover_data):
                    # Convertir le format "2024-04-06T12:00" en datetime
                    try:
                        # Supprimer le 'T' et ajouter les secondes si nécessaire
                        dt_str = timestamp_str.replace('T', ' ')
                        if len(dt_str.split(':')) == 2:
                            dt_str += ':00'  # Ajouter les secondes si non présentes
                        cloud_dt = datetime.fromisoformat(dt_str)
                        cloud_cover_dict[cloud_dt] = cloud_cover_data[i]
                        # LOGGER.debug("Cloud timestamp mapping: %s -> %s%%", dt_str, cloud_cover_data[i])
                    except ValueError as e:
                        LOGGER.error("Error parsing timestamp %s: %s", timestamp_str, e)
        
        # Créer un journal de débogage pour les ajustements
        adjustment_log = {}
        
        # Ajuster les watts (puissance instantanée)
        for timestamp, watts in list(estimate.watts.items()):
            # Chercher la valeur de nébulosité pour ce timestamp spécifique
            cloud_cover_percent = 0
            
            if cloud_cover_dict:
                # Essayer de trouver le timestamp le plus proche
                closest_timestamp = None
                min_difference = timedelta(hours=24)  # Initialiser à une grande valeur
                
                # Convertir timestamp local en UTC si nécessaire pour la comparaison
                utc_timestamp = timestamp
                if timestamp.tzinfo:  # Si timestamp a une timezone
                    utc_timestamp = timestamp.astimezone(timezone.utc).replace(tzinfo=None)
                
                for cloud_dt in cloud_cover_dict:
                    # Calculer la différence en ignorant les secondes/microsecondes
                    dt1 = utc_timestamp.replace(second=0, microsecond=0)
                    dt2 = cloud_dt.replace(second=0, microsecond=0)
                    difference = abs(dt1 - dt2)
                    
                    if difference < min_difference:
                        min_difference = difference
                        closest_timestamp = cloud_dt
                
                # Si on a trouvé un timestamp proche (moins de 2 heures de différence)
                if closest_timestamp and min_difference <= timedelta(hours=2):
                    cloud_cover_percent = cloud_cover_dict[closest_timestamp]
                    # LOGGER.debug(
                    #     "Matched timestamp %s with cloud data timestamp %s (diff: %s), cloud cover: %s%%",
                    #     timestamp, closest_timestamp, min_difference, cloud_cover_percent
                    # )
                else:
                    # Fallback à l'ancienne méthode basée sur l'heure du jour
                    day_offset = (timestamp.date() - estimate.now().date()).days
                    hour_index = timestamp.hour + (day_offset * 24)
                    
                    if 0 <= hour_index < len(cloud_cover_data):
                        cloud_cover_percent = cloud_cover_data[hour_index]
                        # LOGGER.debug(
                        #     "Using fallback hour index method for %s: day_offset=%s, hour=%s, index=%s, cloud cover: %s%%", 
                        #     timestamp, day_offset, timestamp.hour, hour_index, cloud_cover_percent
                        # )
            else:
                # Fallback à l'ancienne méthode basée sur l'heure du jour comme dernier recours
                day_offset = (timestamp.date() - estimate.now().date()).days
                hour_index = timestamp.hour + (day_offset * 24)
                
                if 0 <= hour_index < len(cloud_cover_data):
                    cloud_cover_percent = cloud_cover_data[hour_index]
            

            # Facteur d'ajustement: 100% de nébulosité = réduction de 70% (ajustable selon vos besoins)

            cloud_correction_factor = self.config_entry.options.get(CONF_CLOUD_CORRECTION_FACTOR, DEFAULT_CLOUD_CORRECTION_FACTOR)
            adjustment_factor = 1.0 - (cloud_cover_percent / 100.0 * cloud_correction_factor)
            adjusted_watts = watts * adjustment_factor
                 
            # Appliquer l'ajustement
            estimate.watts[timestamp] = adjusted_watts
        
        # Utiliser la même logique pour ajuster wh_period
        for timestamp, wh in list(estimate.wh_period.items()):
            # Même méthode d'alignement que pour watts
            cloud_cover_percent = 0
            
            # [Répéter la même logique d'alignement que ci-dessus]
            if cloud_cover_dict:
                # Trouver le timestamp le plus proche...
                # [code similaire à ci-dessus]
                pass
            else:
                # Fallback
                day_offset = (timestamp.date() - estimate.now().date()).days
                hour_index = timestamp.hour + (day_offset * 24)
                
                if 0 <= hour_index < len(cloud_cover_data):
                    cloud_cover_percent = cloud_cover_data[hour_index]
            
            adjustment_factor = 1.0 - (cloud_cover_percent / 100.0 * cloud_correction_factor)
            estimate.wh_period[timestamp] = wh * adjustment_factor
            
            # Ajouter au compteur de totaux pour les statistiques
            date_str = timestamp.date().isoformat()
            if date_str in adjustment_log:
                adjustment_log[date_str]["original_total"] += wh
                adjustment_log[date_str]["adjusted_total"] += (wh * adjustment_factor)
        
        # Pour wh_days, calculer une moyenne journalière de nébulosité
        date_cloud_cover = {}  # Stocke la couverture nuageuse moyenne par jour
        
        # Si nous avons des timestamps, calculer la moyenne par jour correctement
        if cloud_timestamps:
            for i, timestamp_str in enumerate(cloud_timestamps):
                if i < len(cloud_cover_data):
                    try:
                        dt_str = timestamp_str.replace('T', ' ')
                        cloud_dt = datetime.fromisoformat(dt_str)
                        date_str = cloud_dt.date().isoformat()
                        
                        if date_str not in date_cloud_cover:
                            date_cloud_cover[date_str] = {
                                "total": cloud_cover_data[i],
                                "count": 1
                            }
                        else:
                            date_cloud_cover[date_str]["total"] += cloud_cover_data[i]
                            date_cloud_cover[date_str]["count"] += 1
                    except ValueError:
                        pass
        # Sinon, faire une estimation plus basique
        else:
            # Diviser les données de cloud_cover_data en tranches de 24h
            for i in range(0, len(cloud_cover_data), 24):
                day_slice = cloud_cover_data[i:i+24]
                if day_slice:
                    day_idx = i // 24
                    today = estimate.now().date()
                    date = today + timedelta(days=day_idx)
                    date_cloud_cover[date.isoformat()] = {
                        "total": sum(day_slice),
                        "count": len(day_slice)
                    }
        
        # Ajuster wh_days avec la nébulosité moyenne par jour
        for day, wh in list(estimate.wh_days.items()):
            date_str = day.isoformat()
            if date_str in date_cloud_cover and date_cloud_cover[date_str]["count"] > 0:
                avg_cloud_cover = date_cloud_cover[date_str]["total"] / date_cloud_cover[date_str]["count"]
            else:
                # Fallback
                day_offset = (day - estimate.now().date()).days
                start_idx = day_offset * 24
                end_idx = start_idx + 24
                day_slice = cloud_cover_data[start_idx:end_idx] if 0 <= start_idx < len(cloud_cover_data) else []
                avg_cloud_cover = sum(day_slice) / len(day_slice) if day_slice else 0
                
            adjustment_factor = 1.0 - (avg_cloud_cover / 100.0 * 0.7)
            estimate.wh_days[day] = wh * adjustment_factor
            
            # Enregistrer pour le débogage ( A garder)
            LOGGER.debug(
                "Day adjustment - %s: avg cloud cover: %.1f%%, original: %.1f, adjusted: %.1f", 
                date_str, avg_cloud_cover, wh, (wh * adjustment_factor)
            )
        
        # Calculer les statistiques d'ajustement
        total_energy_after = sum(estimate.wh_period.values())
        adjustment_pct = ((total_energy_after - total_energy_before) / total_energy_before * 100) if total_energy_before else 0
        
        # Stocker les statistiques et le log d'ajustement
        self.adjustment_stats = {
            "average_cloud_cover": sum(cloud_cover_data[:24])/min(24, len(cloud_cover_data)) if cloud_cover_data else 0,
            "total_energy_before_adjustment": total_energy_before,
            "total_energy_after_adjustment": total_energy_after,
            "adjustment_percentage": adjustment_pct,
            "daily_adjustments": adjustment_log
        }




    async def estimate(self) -> Estimate:
        """Get solar production estimations from the API.

        Returns
        -------
            A Estimate object, with a estimated production forecast.

        """
        w_avg: dict[dt, int] = defaultdict(int)
        w_inst: dict[dt, int] = defaultdict(int)
        wh_days: dict[dt, int] = defaultdict(int)

        def gen_power(gti: float, t_amb: float, eff: float) -> int:
            """Calculate the power generated by a solar panel.

            Formulas:
            ---------
                According to https://www.mdpi.com/2071-1050/14/3/1500 (equations 1 and 2) and Table 1,
                the temperature formula should be:
                     Tc = Ta + G * k
                where:
                    - Tc is the cell temperature
                    - Ta is the ambient temperature
                    - G is the irradiance (W/m²)
                    - k is the Ross coefficient

                For a typical residential PV installation, we use the "Not so well cooled" Ross coefficient
                from Table 1, which is 0.0342. (TODO: make this coefficient configurable.)

                References:
                    - Ross model source: https://www.researchgate.net/publication/275438802_Thermal_effects_of_the_extended_holographic_regions_for_holographic_planar_concentrator
                    - Power output formula: P = Pmax * (G / Gstc) * (1 + α * (Tc - Tstc)) * ηDC (see p.509)
                      Source: https://www.researchgate.net/publication/372240079_Solar_Prediction_Strategy_for_Managing_Virtual_Power_Stations
            """
            temp_cell = t_amb + gti * RossModelConstants.NOT_SO_WELL_COOLED
            power = dc_wp
            power *= gti / G_STC
            power *= 1 + ALPHA_TEMP * (temp_cell - TEMP_STC_CELL)
            power *= eff
            return round(max(0, power))

        def calculate_damping_coefficient(
            time: dt,
            sunrise: dt,
            sunset: dt,
            damping_morning: float,
            damping_evening: float,
        ) -> float:
            """Calculate the damping coefficient for the current time.

            Args:
            ----
                time: The current time.
                sunrise: The time of sunrise.
                sunset: The time of sunset.
                damping_morning: The damping factor for the morning.
                damping_evening: The damping factor for the evening.

            Returns:
            -------
                The damping coefficient for the current time.

            Notes:
            -----
                As the damping factor decreases, the power generated by the solar
                panels increases. For example, when the damping factor is 0, the
                power generated is at its maximum and no damping is applied. When
                the damping factor is 1, the power generated is at its minimum and
                the damping is fully applied.

                This means that if a damping factor of 1.0 is applied for the morning,
                at morning_start the power generated will be 0 as the coefficient would
                be 0.0. As the time approaches morning_end, the coefficient will increase
                linearly until it reaches 1.0 at morning_end. The same applies for the
                evening, but the coefficient will decrease linearly from 1.0 to 0.0.

            """
            morning_start = sunrise
            morning_end = sunrise + (sunset - sunrise) / 2
            evening_start = morning_end
            evening_end = sunset

            def linear_damping(start: dt, end: dt, damping: float) -> float:
                """Calculate the linear damping coefficient."""
                duration = end - start
                elapsed = time - start
                damping = 1.0 - damping  # Invert the damping factor
                return (elapsed / duration) * (1.0 - damping) + damping

            if morning_start <= time <= morning_end:
                return linear_damping(morning_start, morning_end, damping_morning)

            if evening_start <= time <= evening_end:
                return linear_damping(evening_end, evening_start, damping_evening)

            return 1

        utc_offset = None
        for (
            azimuth,
            declination,
            dc_kwp,
            latitude,
            lonitude,
            efficiency,
            damping_morning,
            damping_evening,
        ) in zip(
            self.azimuth,
            self.declination,
            self.dc_kwp,
            self.latitude,
            self.longitude,
            self.efficiency_factor,
            self.damping_morning,
            self.damping_evening,
            strict=True,
        ):
            params = {
                "latitude": str(latitude),
                "longitude": str(lonitude),
                "azimuth": str(azimuth),
                "tilt": str(declination),
                "minutely_15": "temperature_2m"
                ",global_tilted_irradiance,global_tilted_irradiance_instant",
                "daily": "sunrise,sunset",
                "forecast_days": str(self.forecast_days),
                "past_days": str(self.past_days),
                "timezone": "auto",
            }
            data = await self._request(
                "/v1/forecast",
                params=params,
            )
            gti_avg_arr = data["minutely_15"]["global_tilted_irradiance"]
            gti_inst_arr = data["minutely_15"]["global_tilted_irradiance_instant"]
            temp_arr = data["minutely_15"]["temperature_2m"]
            if utc_offset is None:
                utc_offset = data["utc_offset_seconds"]
            elif utc_offset != data["utc_offset_seconds"]:
                raise OpenMeteoSolarForecastConfigError(
                    "The UTC offset is not the same for all locations"
                )
            time_arr = [
                dt.strptime(time, "%Y-%m-%dT%H:%M").replace(
                    tzinfo=timezone(timedelta(seconds=utc_offset))
                )
                for time in data["minutely_15"]["time"]
            ]
            sunrise_dict = {
                dt.strptime(time, "%Y-%m-%dT%H:%M")
                .replace(tzinfo=timezone(timedelta(seconds=utc_offset)))
                .date(): dt.strptime(time, "%Y-%m-%dT%H:%M")
                .replace(tzinfo=timezone(timedelta(seconds=utc_offset)))
                for time in data["daily"]["sunrise"]
            }
            sunset_dict = {
                dt.strptime(time, "%Y-%m-%dT%H:%M")
                .replace(tzinfo=timezone(timedelta(seconds=utc_offset)))
                .date(): dt.strptime(time, "%Y-%m-%dT%H:%M")
                .replace(tzinfo=timezone(timedelta(seconds=utc_offset)))
                for time in data["daily"]["sunset"]
            }
            damping_factors = [
                calculate_damping_coefficient(
                    time,
                    sunrise_dict[time.date()],
                    sunset_dict[time.date()],
                    damping_morning,
                    damping_evening,
                )
                for time in time_arr
            ]

            # Convert kW to W
            dc_wp = dc_kwp * 1000

            for i, time in enumerate(time_arr):
                # Skip the first element as we need the previous element to calculate
                # the average temperature for the current time
                if i - 1 < 0:
                    continue

                # Skip if any of the values are None
                if None in (
                    gti_avg_arr[i],
                    gti_inst_arr[i],
                    *temp_arr[i - 1 : i + 1],
                ):
                    continue

                # Get the GTI for average and instantaneous values
                g_avg = gti_avg_arr[i]
                g_inst = gti_inst_arr[i]

                # Get the temperature for average and instantaneous values
                temp_avg = (temp_arr[i] + temp_arr[i - 1]) / 2
                temp_inst = temp_arr[i - 1]

                # For minutely data, the GTI start time is 15 minutes before the time
                # even for instant data (since the data is averaged over 15 minutes)
                time_start = time - timedelta(minutes=15)

                # Add the damping factor to the efficiency
                eff_damped = efficiency * damping_factors[i]

                # Calculate and store the power generated
                w_avg[time_start] += gen_power(g_avg, temp_avg, eff_damped)
                w_inst[time_start] += gen_power(g_inst, temp_inst, eff_damped)

        # Clamp the power generated to the AC power
        ac_wp = self.ac_kwp * 1000  # Convert kW to W
        for time in w_avg:
            w_avg[time] = min(w_avg[time], ac_wp)
        for time in w_inst:
            w_inst[time] = min(w_inst[time], ac_wp)

        # Calculate the average power generated per hour
        wh_period: dict[dt, int] = {}
        wh_period_count: dict[dt, int] = {}
        for time, power in w_avg.items():
            hour = time.replace(minute=0, second=0, microsecond=0)
            wh_period[hour] = wh_period.get(hour, 0) + power
            wh_period_count[hour] = wh_period_count.get(hour, 0) + 1
        for time in wh_period:
            wh_period[time] /= wh_period_count[time]

        # Calculate the total energy produced per day
        for time, power in wh_period.items():
            day = time.date()
            wh_days[day] = wh_days.get(day, 0) + power

        # Return the estimate object
        estimate = Estimate(
            watts=w_inst,
            wh_period=wh_period,
            wh_days=wh_days,
            api_timezone=timezone(timedelta(seconds=utc_offset)),
        )
        
        cloud_cover_data = await self._fetch_hourly_cloud_cover()
        self._adjust_estimate_with_cloud_cover(estimate, cloud_cover_data)
        
        return estimate

    async def close(self) -> None:
        """Close open client session."""
        if self.session and self._close_session:
            await self.session.close()

    async def __aenter__(self) -> Self:
        """Async enter.

        Returns
        -------
            The OpenMeteoSolarForecast object.

        """
        return self

    async def __aexit__(self, *_exc_info: object) -> None:
        """Async exit.

        Args:
        ----
            _exc_info: Exec type.

        """
        await self.close()


---
# custom_components/ha_sunforecast_plus/recorder.py
---

"""Integration platform for recorder."""

from __future__ import annotations

from homeassistant.core import HomeAssistant, callback

from .const import ATTR_WATTS, ATTR_WH_PERIOD


@callback
def exclude_attributes(hass: HomeAssistant) -> set[str]:
    """Exclude potentially large attributes from being recorded in the database."""
    return {ATTR_WATTS, ATTR_WH_PERIOD}


---
# custom_components/ha_sunforecast_plus/sensor.py
---

"""Support for Sun Forecast Plus sensor service."""

from __future__ import annotations

from collections.abc import Callable
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Any

from homeassistant.components.sensor import (
    DOMAIN as SENSOR_DOMAIN,
)
from homeassistant.components.sensor import (
    SensorDeviceClass,
    SensorEntity,
    SensorEntityDescription,
    SensorStateClass,
)
from homeassistant.config_entries import ConfigEntry
from homeassistant.const import UnitOfEnergy, UnitOfPower
from homeassistant.core import HomeAssistant
from homeassistant.helpers.device_registry import DeviceEntryType, DeviceInfo
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.event import async_track_utc_time_change
from homeassistant.helpers.typing import StateType
from homeassistant.helpers.update_coordinator import CoordinatorEntity

from .estimate import Estimate

from .const import ATTR_WATTS, ATTR_WH_PERIOD, DOMAIN
from .coordinator import OpenMeteoSolarForecastDataUpdateCoordinator





@dataclass(frozen=True)
class OpenMeteoSolarForecastSensorEntityDescription(SensorEntityDescription):
    """Describes a Forecast.Solar Sensor."""

    state: Callable[[Estimate], Any] | None = None


SENSORS: tuple[OpenMeteoSolarForecastSensorEntityDescription, ...] = (
    OpenMeteoSolarForecastSensorEntityDescription(
        key="energy_production_today",
        translation_key="energy_production_today",
        state=lambda estimate: estimate.energy_production_today,
        device_class=SensorDeviceClass.ENERGY,
        native_unit_of_measurement=UnitOfEnergy.WATT_HOUR,
        suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR,
        suggested_display_precision=1,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="energy_production_today_remaining",
        translation_key="energy_production_today_remaining",
        state=lambda estimate: estimate.energy_production_today_remaining,
        device_class=SensorDeviceClass.ENERGY,
        native_unit_of_measurement=UnitOfEnergy.WATT_HOUR,
        suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR,
        suggested_display_precision=1,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="energy_production_tomorrow",
        translation_key="energy_production_tomorrow",
        state=lambda estimate: estimate.energy_production_tomorrow,
        device_class=SensorDeviceClass.ENERGY,
        native_unit_of_measurement=UnitOfEnergy.WATT_HOUR,
        suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR,
        suggested_display_precision=1,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="energy_production_d2",
        translation_key="energy_production_d2",
        state=lambda estimate: estimate.day_production(
            estimate.now().date() + timedelta(days=2)
        ),
        device_class=SensorDeviceClass.ENERGY,
        native_unit_of_measurement=UnitOfEnergy.WATT_HOUR,
        suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR,
        suggested_display_precision=1,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="energy_production_d3",
        translation_key="energy_production_d3",
        state=lambda estimate: estimate.day_production(
            estimate.now().date() + timedelta(days=3)
        ),
        device_class=SensorDeviceClass.ENERGY,
        native_unit_of_measurement=UnitOfEnergy.WATT_HOUR,
        suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR,
        suggested_display_precision=1,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="energy_production_d4",
        translation_key="energy_production_d4",
        state=lambda estimate: estimate.day_production(
            estimate.now().date() + timedelta(days=4)
        ),
        device_class=SensorDeviceClass.ENERGY,
        native_unit_of_measurement=UnitOfEnergy.WATT_HOUR,
        suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR,
        suggested_display_precision=1,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="energy_production_d5",
        translation_key="energy_production_d5",
        state=lambda estimate: estimate.day_production(
            estimate.now().date() + timedelta(days=5)
        ),
        device_class=SensorDeviceClass.ENERGY,
        native_unit_of_measurement=UnitOfEnergy.WATT_HOUR,
        suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR,
        suggested_display_precision=1,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="energy_production_d6",
        translation_key="energy_production_d6",
        state=lambda estimate: estimate.day_production(
            estimate.now().date() + timedelta(days=6)
        ),
        device_class=SensorDeviceClass.ENERGY,
        native_unit_of_measurement=UnitOfEnergy.WATT_HOUR,
        suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR,
        suggested_display_precision=1,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="energy_production_d7",
        translation_key="energy_production_d7",
        state=lambda estimate: estimate.day_production(
            estimate.now().date() + timedelta(days=7)
        ),
        device_class=SensorDeviceClass.ENERGY,
        native_unit_of_measurement=UnitOfEnergy.WATT_HOUR,
        suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR,
        suggested_display_precision=1,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="power_highest_peak_time_today",
        translation_key="power_highest_peak_time_today",
        device_class=SensorDeviceClass.TIMESTAMP,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="power_highest_peak_time_tomorrow",
        translation_key="power_highest_peak_time_tomorrow",
        device_class=SensorDeviceClass.TIMESTAMP,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="power_production_now",
        translation_key="power_production_now",
        device_class=SensorDeviceClass.POWER,
        state=lambda estimate: estimate.power_production_now,
        state_class=SensorStateClass.MEASUREMENT,
        native_unit_of_measurement=UnitOfPower.WATT,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="power_production_next_15minutes",
        translation_key="power_production_next_15minutes",
        state=lambda estimate: estimate.power_production_at_time(
            estimate.now() + timedelta(minutes=15)
        ),
        device_class=SensorDeviceClass.POWER,
        entity_registry_enabled_default=False,
        native_unit_of_measurement=UnitOfPower.WATT,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="power_production_next_30minutes",
        translation_key="power_production_next_30minutes",
        state=lambda estimate: estimate.power_production_at_time(
            estimate.now() + timedelta(minutes=30)
        ),
        device_class=SensorDeviceClass.POWER,
        entity_registry_enabled_default=False,
        native_unit_of_measurement=UnitOfPower.WATT,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="power_production_next_hour",
        translation_key="power_production_next_hour",
        state=lambda estimate: estimate.power_production_at_time(
            estimate.now() + timedelta(hours=1)
        ),
        device_class=SensorDeviceClass.POWER,
        entity_registry_enabled_default=False,
        native_unit_of_measurement=UnitOfPower.WATT,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="power_production_next_12hours",
        translation_key="power_production_next_12hours",
        state=lambda estimate: estimate.power_production_at_time(
            estimate.now() + timedelta(hours=12)
        ),
        device_class=SensorDeviceClass.POWER,
        entity_registry_enabled_default=False,
        native_unit_of_measurement=UnitOfPower.WATT,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="power_production_next_24hours",
        translation_key="power_production_next_24hours",
        state=lambda estimate: estimate.power_production_at_time(
            estimate.now() + timedelta(hours=24)
        ),
        device_class=SensorDeviceClass.POWER,
        entity_registry_enabled_default=False,
        native_unit_of_measurement=UnitOfPower.WATT,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="energy_current_hour",
        translation_key="energy_current_hour",
        state=lambda estimate: estimate.energy_current_hour,
        device_class=SensorDeviceClass.ENERGY,
        native_unit_of_measurement=UnitOfEnergy.WATT_HOUR,
        suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR,
        suggested_display_precision=1,
    ),
    OpenMeteoSolarForecastSensorEntityDescription(
        key="energy_next_hour",
        translation_key="energy_next_hour",
        state=lambda estimate: estimate.sum_energy_production(1),
        device_class=SensorDeviceClass.ENERGY,
        native_unit_of_measurement=UnitOfEnergy.WATT_HOUR,
        suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR,
        suggested_display_precision=1,
    ),
)

async def async_setup_entry(
    hass: HomeAssistant, entry: ConfigEntry, async_add_entities: AddEntitiesCallback
) -> None:
    """Defer sensor setup to the shared sensor module."""
    coordinator: OpenMeteoSolarForecastDataUpdateCoordinator = hass.data[DOMAIN][
        entry.entry_id
    ]
    entities = []
    
    # Ajouter tous les capteurs standard
    for entity_description in SENSORS:
        entities.append(
            OpenMeteoSolarForecastSensorEntity(
                entry_id=entry.entry_id,
                coordinator=coordinator,
                entity_description=entity_description,
            )
        )
        
    async_add_entities(entities)

class OpenMeteoSolarForecastSensorEntity(
    CoordinatorEntity[OpenMeteoSolarForecastDataUpdateCoordinator], SensorEntity
):
    """Defines a Open-Meteo sensor."""
    entity_description: OpenMeteoSolarForecastSensorEntityDescription
    _attr_has_entity_name = True
    def __init__(
        self,
        *,
        entry_id: str,
        coordinator: OpenMeteoSolarForecastDataUpdateCoordinator,
        entity_description: OpenMeteoSolarForecastSensorEntityDescription,
    ) -> None:
        """Initialize Open-Meteo Solar sensor."""
        super().__init__(coordinator=coordinator)
        self.entity_description = entity_description
        #self.entity_id = f"{SENSOR_DOMAIN}.{entity_description.key}"
        self._attr_unique_id = f"{entry_id}_{entity_description.key}"
        self._attr_device_info = DeviceInfo(
            entry_type=DeviceEntryType.SERVICE,
            identifiers={(DOMAIN, entry_id)},
            manufacturer="Open-Meteo",
            name="Solar production forecast",
            configuration_url="https://open-meteo.com",
        )
    async def _update_callback(self, now: datetime) -> None:
        """Update the entity without fetching data from server.
        This is required for the power_production_* sensors to update
        as they take data in 15-minute intervals and the update interval
        is 30 minutes."""
        self.async_write_ha_state()


    async def async_added_to_hass(self) -> None:
        """Register callbacks."""
        await super().async_added_to_hass()
        # Update the state of the sensor every minute without
        # fetching new data from the server.
        if "power_production_next_" in self.entity_description.key:
            async_track_utc_time_change(
                self.hass,
                self._update_callback,
                minute=[0, 15, 30, 45],
                second=0,
        )
    @property
    def native_value(self) -> datetime | StateType:
        """Return the state of the sensor."""
        if self.entity_description.state is None:
            state: StateType | datetime = getattr(
                self.coordinator.data, self.entity_description.key
            )
        else:
            state = self.entity_description.state(self.coordinator.data)
        return state
    @property
    def extra_state_attributes(self) -> dict[str, Any] | None:
        """Return the state attributes."""
        attrs = None
        
        if self.entity_description.key.startswith(
            "energy_production_d"
        ) or self.entity_description.key in (
            "energy_production_today",
            "energy_production_tomorrow",
        ):
            target_date = self.coordinator.data.now().date()
            if self.entity_description.key == "energy_production_tomorrow":
                target_date += timedelta(days=1)
            elif self.entity_description.key.startswith("energy_production_d"):
                target_date += timedelta(
                    days=int(self.entity_description.key[len("energy_production_d") :])
                )
            elif self.entity_description.key == "energy_production_today":
                pass  # target_date is already set to today
            else:
                raise ValueError(
                    f"Unexpected key {self.entity_description.key} for extra_state_attributes"
                )
            attrs = {
                ATTR_WATTS: {
                    watt_datetime.isoformat(): watt_value
                    for watt_datetime, watt_value in self.coordinator.data.watts.items()
                    if watt_datetime.date() == target_date
                },
                ATTR_WH_PERIOD: {
                    wh_datetime.isoformat(): wh_value
                    for wh_datetime, wh_value in self.coordinator.data.wh_period.items()
                    if wh_datetime.date() == target_date
                },
            }
        else:
            attrs = {}
            
        # Ajouter les informations d'ajustement de nébulosité seulement pour les capteurs d'énergie
        if hasattr(self.coordinator, "adjustment_stats") and self.entity_description.key.startswith("energy_"):
            cloud_info = {
                "average_cloud_cover": f"{self.coordinator.adjustment_stats.get('average_cloud_cover', 0):.1f}%",
                "adjustment": f"{self.coordinator.adjustment_stats.get('adjustment_percentage', 0):.1f}%"
            }
            
            if not attrs:
                attrs = {}
                
            attrs["cloud_adjustment"] = cloud_info
            
        return attrs
        

---
# custom_components/ha_sunforecast_plus/strings.json
---

{
  "config": {
    "step": {
      "user": {
        "description": "Fill in the data of your solar panels.",
        "data": {
          "api_key": "[%key:common::config_flow::data::api_key%]",
          "azimuth": "Azimuth (360 degrees, 0 = North, 90 = East, 180 = South, 270 = West)",
          "damping_morning": "Damping factor: adjusts the results in the morning",
          "damping_evening": "Damping factor: adjusts the results in the evening",
          "declination": "Declination (0 = Horizontal, 90 = Vertical)",
          "latitude": "[%key:common::config_flow::data::latitude%]",
          "longitude": "[%key:common::config_flow::data::longitude%]",
          "efficiency_factor": "DC efficiency factor (0.0-1.0, 0.0 = 100% loss, 1.0 = no loss)",
          "modules_power": "Total Watt peak power of your solar modules",
          "inverter_power": "The capacity of your inverter in Watt",
          "name": "[%key:common::config_flow::data::name%]",
          "model": "The weather model to use",
          "cloud_model": "The cloud_cover model to use",
          "cloud_correction_factor":"Damping factor for cloud covering"
        }
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "[%key:common::config_flow::error::invalid_api_key%]"
    },
    "step": {
      "init": {
        "description": "[%key:component::solar_forecast::config::step::user::description%]",
        "data": {
          "api_key": "[%key:common::config_flow::data::api_key%]",
          "azimuth": "[%key:component::solar_forecast::config::step::user::data::azimuth%]",
          "damping_morning": "[%key:component::solar_forecast::config::step::user::data::damping_morning%]",
          "damping_evening": "[%key:component::solar_forecast::config::step::user::data::damping_evening%]",
          "declination": "[%key:component::solar_forecast::config::step::user::data::declination%]",
          "efficiency_factor": "[%key:component::solar_forecast::config::step::user::data::efficiency_factor%]",
          "modules_power": "[%key:component::solar_forecast::config::step::user::data::modules_power%]",
          "inverter_power": "[%key:component::solar_forecast::config::step::user::data::inverter_power%]",
          "model": "[%key:component::solar_forecast::config::step::user::data::model%]",
          "cloud_model": "The cloud_cover model to use",
          "cloud_correction_factor":"Damping factor for cloud covering"

        }
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_production_today": {
        "name": "Estimated energy production - today"
      },
      "energy_production_today_remaining": {
        "name": "Estimated energy production - remaining today"
      },
      "energy_production_tomorrow": {
        "name": "Estimated energy production - tomorrow"
      },
      "energy_production_d2": {
        "name": "Estimated energy production - day after tomorrow"
      },
      "energy_production_d3": {
        "name": "Estimated energy production - 3 days from now"
      },
      "energy_production_d4": {
        "name": "Estimated energy production - 4 days from now"
      },
      "energy_production_d5": {
        "name": "Estimated energy production - 5 days from now"
      },
      "energy_production_d6": {
        "name": "Estimated energy production - 6 days from now"
      },
      "energy_production_d7": {
        "name": "Estimated energy production - 7 days from now"
      },
      "power_highest_peak_time_today": {
        "name": "Highest power peak time - today"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Highest power peak time - tomorrow"
      },
      "power_production_now": {
        "name": "Estimated power production - now"
      },
      "power_production_next_15minutes": {
        "name": "Estimated power production - next 15 minutes"
      },
      "power_production_next_30minutes": {
        "name": "Estimated power production - next 30 minutes"
      },
      "power_production_next_hour": {
        "name": "Estimated power production - next hour"
      },
      "power_production_next_12hours": {
        "name": "Estimated power production - next 12 hours"
      },
      "power_production_next_24hours": {
        "name": "Estimated power production - next 24 hours"
      },
      "energy_current_hour": {
        "name": "Estimated energy production - this hour"
      },
      "energy_next_hour": {
        "name": "Estimated energy production - next hour"
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/ar.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "modules_power": "إجمالي طاقة ذروة واط لوحدات الطاقة الشمسية الخاصة بك"
        }
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/bg.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "api_key": "API ключ",
          "azimuth": "Азимут (360 градуса, 0 = Север, 90 = Изток, 180 = Юг, 270 = Запад)",
          "declination": "Деклинация (0 = хоризонтално, 90 = вертикално)",
          "latitude": "Географска ширина",
          "longitude": "Географска дължина",
          "modules_power": "Обща върхова мощност на слънчевите модули във ватове",
          "name": "Име"
        }
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Невалиден API ключ"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "API ключ",
          "azimuth": "Азимут (360 градуса, 0 = Север, 90 = Изток, 180 = Юг, 270 = Запад)",
          "declination": "Деклинация (0 = хоризонтално, 90 = вертикално)",
          "inverter_size": "Размер на инвертора (Вата)"
        }
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/ca.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "api_key": "Clau API",
          "azimuth": "Azimut (360 graus, 0 = nord, 90 = est, 180 = sud, 270 = oest)",
          "declination": "Inclinació (0 = horitzontal, 90 = vertical)",
          "latitude": "Latitud",
          "longitude": "Longitud",
          "modules_power": "Potència màxima total dels panells solars",
          "name": "Nom"
        },
        "description": "Introdueix les dades dels teus panells solars. Consulta la documentació si tens dubtes en algun camp."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Producció d'energia estimada - aquesta hora"
      },
      "energy_next_hour": {
        "name": "Producció d'energia estimada - pròxima hora"
      },
      "energy_production_today": {
        "name": "Producció d'energia estimada - avui"
      },
      "energy_production_today_remaining": {
        "name": "Producció d'energia estimada - avui restant"
      },
      "energy_production_tomorrow": {
        "name": "Producció d'energia estimada - demà"
      },
      "power_highest_peak_time_today": {
        "name": "Hora de màxima potència - avui"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Hora de màxima potència - demà"
      },
      "power_production_next_12hours": {
        "name": "Producció d'energia estimada - pròximes 12 hores"
      },
      "power_production_next_24hours": {
        "name": "Producció d'energia estimada - pròximes 24 hores"
      },
      "power_production_next_hour": {
        "name": "Producció d'energia estimada - pròxima hora"
      },
      "power_production_now": {
        "name": "Producció d'energia estimada - ara"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Clau API invàlida"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "Clau API",
          "azimuth": "Azimut (360 graus, 0 = nord, 90 = est, 180 = sud, 270 = oest)",
          "damping": "Factor d'amortiment: ajusta els resultats al matí i al vespre",
          "damping_evening": "Factor d'amortiment: ajusta els resultats al vespre",
          "damping_morning": "Factor d'amortiment: ajusta els resultats al matí",
          "declination": "Inclinació (0 = horitzontal, 90 = vertical)",
          "inverter_size": "Potència de l'inversor (Watts)",
          "modules_power": "Potència màxima total dels panells solars"
        },
        "description": "Aquests valors permeten ajustar els resultats de Forecast.Solar. Consulta la documentació si tens dubtes sobre algun camp."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/cs.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "api_key": "Klíč API",
          "azimuth": "Azimut (360˚, 0 = sever, 90 = východ, 180 = jih, 270 = západ)",
          "declination": "Deklinace (0 = horizontální, 90 = vertikální)",
          "latitude": "Zeměpisná šířka",
          "longitude": "Zeměpisná délka",
          "modules_power": "Celkový špičkový výkon solárních modulů ve Wattech",
          "name": "Název"
        },
        "description": "Vyplňte údaje o vašich solárních panelech. Pokud je některé pole nejasné, nahlédněte do dokumentace."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Odhadovaná výroba energie - tato hodina"
      },
      "energy_next_hour": {
        "name": "Odhadovaná výroba energie - příští hodina"
      },
      "energy_production_today": {
        "name": "Odhadovaná výroba energie - dnes"
      },
      "energy_production_today_remaining": {
        "name": "Odhadovaná výroba energie - zbývající dnes"
      },
      "energy_production_tomorrow": {
        "name": "Odhadovaná výroba energie - zítra"
      },
      "power_highest_peak_time_today": {
        "name": "Nejvyšší výkonová špička - dnes"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Nejvyšší výkonová špička - zítra"
      },
      "power_production_next_12hours": {
        "name": "Odhadovaná výroba energie - příštích 12 hodin"
      },
      "power_production_next_24hours": {
        "name": "Odhadovaná výroba energie - příštích 24 hodin"
      },
      "power_production_next_hour": {
        "name": "Odhadovaná výroba energie - příští hodina"
      },
      "power_production_now": {
        "name": "Odhadovaná výroba energie - nyní"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Neplatný klíč API"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "Klíč API",
          "azimuth": "Azimut (360˚, 0 = sever, 90 = východ, 180 = jih, 270 = západ)",
          "damping": "Činitel tlumení: upravuje výsledky ráno a večer",
          "damping_evening": "Činitel tlumení: upravuje výsledky večer",
          "damping_morning": "Činitel tlumení: upravuje výsledky ráno",
          "declination": "Deklinace (0 = horizontální, 90 = vertikální)",
          "inverter_size": "Velikost měniče (W)",
          "modules_power": "Celkový špičkový výkon solárních modulů ve Wattech"
        },
        "description": "Tyto hodnoty umožňují vyladit výsledky Forecast.Solar. Pokud některé pole není jasné, nahlédněte do dokumentace."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/da.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "latitude": "Breddegrad",
          "longitude": "Længdegrad",
          "name": "Navn"
        }
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Ugyldig API-nøgle"
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/de.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "api_key": "API-Schlüssel",
          "azimuth": "Azimut (360 Grad, 0 = Norden, 90 = Osten, 180 = Süden, 270 = Westen)",
          "declination": "Deklination (0 = Horizontal, 90 = Vertikal)",
          "latitude": "Breitengrad",
          "longitude": "Längengrad",
          "modules_power": "Gesamt-Watt-Spitzenleistung deiner Solarmodule",
          "name": "Name"
        },
        "description": "Gib die Daten deiner Solarmodule ein. Wenn ein Feld unklar ist, schlage bitte in der Dokumentation nach."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Geschätzte Energieproduktion – diese Stunde"
      },
      "energy_next_hour": {
        "name": "Geschätzte Energieproduktion – nächste Stunde"
      },
      "energy_production_today": {
        "name": "Geschätzte Energieproduktion – heute"
      },
      "energy_production_today_remaining": {
        "name": "Geschätzte Energieproduktion – heute noch verbleibend"
      },
      "energy_production_tomorrow": {
        "name": "Geschätzte Energieproduktion – morgen"
      },
      "power_highest_peak_time_today": {
        "name": "Höchste Leistungsspitzenzeit - heute"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Höchste Leistungsspitzenzeit - morgen"
      },
      "power_production_next_12hours": {
        "name": "Geschätzte Stromproduktion – nächste 12 Stunden"
      },
      "power_production_next_24hours": {
        "name": "Geschätzte Stromproduktion – nächste 24 Stunden"
      },
      "power_production_next_hour": {
        "name": "Geschätzte Stromproduktion – nächste Stunde"
      },
      "power_production_now": {
        "name": "Geschätzte Stromproduktion – jetzt"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Ungültiger API-Schlüssel"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "API-Schlüssel",
          "azimuth": "Azimut (360 Grad, 0 = Norden, 90 = Osten, 180 = Süden, 270 = Westen)",
          "damping": "Dämpfungsfaktor: passt die Ergebnisse morgens und abends an",
          "damping_evening": "Dämpfungsfaktor: Passt die Ergebnisse am Abend an",
          "damping_morning": "Dämpfungsfaktor: Passt die Ergebnisse am Morgen an",
          "declination": "Deklination (0 = Horizontal, 90 = Vertikal)",
          "inverter_size": "Wechselrichtergröße (Watt)",
          "modules_power": "Gesamt-Watt-Spitzenleistung deiner Solarmodule"
        },
        "description": "Mit diesen Werten kann das Ergebnis von Forecast.Solar angepasst werden. Wenn ein Feld unklar ist, lies bitte in der Dokumentation nach."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/el.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Αζιμούθιο (360 μοίρες, 0 = Βορράς, 90 = Ανατολή, 180 = Νότος, 270 = Δύση)",
          "declination": "Απόκλιση (0 = οριζόντια, 90 = κατακόρυφη)",
          "latitude": "Γεωγραφικό πλάτος",
          "longitude": "Γεωγραφικό μήκος",
          "modules_power": "Συνολική μέγιστη ισχύς Watt των ηλιακών σας μονάδων",
          "name": "Ονομα"
        },
        "description": "Συμπληρώστε τα δεδομένα των ηλιακών σας συλλεκτών. Ανατρέξτε στην τεκμηρίωση εάν ένα πεδίο είναι ασαφές."
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Μη έγκυρο κλειδί API"
    },
    "step": {
      "init": {
        "data": {
          "damping": "Συντελεστής απόσβεσης: ρυθμίζει τα αποτελέσματα πρωί και βράδυ",
          "inverter_size": "Μέγεθος μετατροπέα (Watt)"
        },
        "description": "Αυτές οι τιμές επιτρέπουν την προσαρμογή του αποτελέσματος Forecast.Solar. Ανατρέξτε στην τεκμηρίωση εάν ένα πεδίο είναι ασαφές."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/en-GB.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "modules_power": "Total Watt peak power of your solar modules"
        }
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Estimated energy production - this hour"
      },
      "energy_next_hour": {
        "name": "Estimated energy production - next hour"
      },
      "energy_production_today": {
        "name": "Estimated energy production - today"
      },
      "energy_production_today_remaining": {
        "name": "Estimated energy production - remaining today"
      },
      "energy_production_tomorrow": {
        "name": "Estimated energy production - tomorrow"
      },
      "power_highest_peak_time_today": {
        "name": "Highest power peak time - today"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Highest power peak time - tomorrow"
      },
      "power_production_next_12hours": {
        "name": "Estimated power production - next 12 hours"
      },
      "power_production_next_24hours": {
        "name": "Estimated power production - next 24 hours"
      },
      "power_production_next_hour": {
        "name": "Estimated power production - next hour"
      },
      "power_production_now": {
        "name": "Estimated power production - now"
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/en.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "api_key": "API key",
          "azimuth": "Azimuth (360 degrees, 0 = North, 90 = East, 180 = South, 270 = West)",
          "damping_morning": "Damping factor: adjusts the results in the morning",
          "damping_evening": "Damping factor: adjusts the results in the evening",
          "declination": "Declination (0 = Horizontal, 90 = Vertical)",
          "latitude": "Latitude",
          "longitude": "Longitude",
          "efficiency_factor": "DC efficiency factor (0.0-1.0, 0.0 = 100% loss, 1.0 = no loss)",
          "modules_power": "Total Watt peak power of your solar modules",
          "inverter_power": "The capacity of your inverter in Watt",
          "name": "Name",
          "model": "The weather model to use"
        },
        "description": "Fill in the data of your solar panels. Please refer to the documentation if a field is unclear."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Estimated energy production - this hour"
      },
      "energy_next_hour": {
        "name": "Estimated energy production - next hour"
      },
      "energy_production_today": {
        "name": "Estimated energy production - today"
      },
      "energy_production_today_remaining": {
        "name": "Estimated energy production - remaining today"
      },
      "energy_production_tomorrow": {
        "name": "Estimated energy production - tomorrow"
      },
      "energy_production_d2": {
        "name": "Estimated energy production - day after tomorrow"
      },
      "energy_production_d3": {
        "name": "Estimated energy production - 3 days from now"
      },
      "energy_production_d4": {
        "name": "Estimated energy production - 4 days from now"
      },
      "energy_production_d5": {
        "name": "Estimated energy production - 5 days from now"
      },
      "energy_production_d6": {
        "name": "Estimated energy production - 6 days from now"
      },
      "energy_production_d7": {
        "name": "Estimated energy production - 7 days from now"
      },
      "power_highest_peak_time_today": {
        "name": "Highest power peak time - today"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Highest power peak time - tomorrow"
      },
      "power_production_next_12hours": {
        "name": "Estimated power production - next 12 hours"
      },
      "power_production_next_24hours": {
        "name": "Estimated power production - next 24 hours"
      },
      "power_production_next_hour": {
        "name": "Estimated power production - next hour"
      },
      "power_production_now": {
        "name": "Estimated power production - now"
      },
      "power_production_next_15minutes": {
        "name": "Estimated power production - next 15 minutes"
      },
      "power_production_next_30minutes": {
        "name": "Estimated power production - next 30 minutes"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Invalid API key"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "API key",
          "azimuth": "Azimuth (360 degrees, 0 = North, 90 = East, 180 = South, 270 = West)",
          "damping_morning": "Damping factor: adjusts the results in the morning",
          "damping_evening": "Damping factor: adjusts the results in the evening",
          "declination": "Declination (0 = Horizontal, 90 = Vertical)",
          "inverter_size": "Inverter size (Watt)",
          "efficiency_factor": "DC efficiency factor (0.0-1.0, 0.0 = 100% loss, 1.0 = no loss)",
          "modules_power": "Total Watt peak power of your solar modules",
          "inverter_power": "The capacity of your inverter in Watt",
          "model": "The weather model to use"
        },
        "description": "These values allow tweaking the Forecast.Solar result. Please refer to the documentation if a field is unclear."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/es-419.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimut (360 grados, 0 = Norte, 90 = Este, 180 = Sur, 270 = Oeste)",
          "declination": "Declinación (0 = Horizontal, 90 = Vertical)",
          "modules_power": "Potencia pico total en vatios de sus módulos solares"
        },
        "description": "Complete los datos de sus paneles solares. Consulte la documentación si un campo no está claro."
      }
    }
  },
  "options": {
    "step": {
      "init": {
        "data": {
          "damping": "Factor de amortiguación: ajusta los resultados por la mañana y por la noche"
        }
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/es.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimut (360 grados, 0 = Norte, 90 = Este, 180 = Sur, 270 = Oeste)",
          "declination": "Declinación (0 = Horizontal, 90 = Vertical)",
          "latitude": "Latitud",
          "longitude": "Longitud",
          "modules_power": "Potencia pico total en vatios de tus módulos solares",
          "name": "Nombre"
        },
        "description": "Rellena los datos de tus placas solares. Por favor, consulta la documentación si un campo no está claro."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Producción de energía estimada - esta hora"
      },
      "energy_next_hour": {
        "name": "Producción de energía estimada - próxima hora"
      },
      "energy_production_today": {
        "name": "Producción de energía estimada - hoy"
      },
      "energy_production_today_remaining": {
        "name": "Producción de energía estimada - restante hoy"
      },
      "energy_production_tomorrow": {
        "name": "Producción de energía estimada - mañana"
      },
      "power_highest_peak_time_today": {
        "name": "Hora pico de mayor potencia - hoy"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Hora pico de mayor potencia - mañana"
      },
      "power_production_next_12hours": {
        "name": "Producción de energía estimada - próximas 12 horas"
      },
      "power_production_next_24hours": {
        "name": "Producción de energía estimada - próximas 24 horas"
      },
      "power_production_next_hour": {
        "name": "Producción de energía estimada - próxima hora"
      },
      "power_production_now": {
        "name": "Producción de energía estimada - ahora"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Clave API no válida"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "Clave API",
          "azimuth": "Azimut (360 grados, 0 = Norte, 90 = Este, 180 = Sur, 270 = Oeste)",
          "damping": "Factor de amortiguación: ajusta los resultados por la mañana y por la noche",
          "damping_evening": "Factor de amortiguación: ajusta los resultados por la noche.",
          "damping_morning": "Factor de amortiguación: ajusta los resultados por la mañana.",
          "declination": "Declinación (0 = Horizontal, 90 = Vertical)",
          "inverter_size": "Tamaño del inversor (vatios)",
          "modules_power": "Potencia pico total en vatios de tus módulos solares"
        },
        "description": "Estos valores permiten modificar el resultado de Forecast.Solar. Por favor, consulta la documentación si un campo no está claro."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/et.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Asimuut (360 kraadi, 0 = põhi, 90 = ida, 180 = lõuna, 270 = lääs)",
          "declination": "Deklinatsioon (0 = horisontaalne, 90 = vertikaalne)",
          "latitude": "Laiuskraad",
          "longitude": "Pikkuskraad",
          "modules_power": "Päikesemoodulite koguvõimsus vattides",
          "name": "Nimi"
        },
        "description": "Sisesta oma päikesepaneelide andmed. Kui väli on ebaselge, loe dokumentatsiooni."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Hinnanguline energiatoodang – see tund"
      },
      "energy_next_hour": {
        "name": "Hinnanguline energiatoodang – järgmine tund"
      },
      "energy_production_today": {
        "name": "Hinnanguline energiatoodang – täna"
      },
      "energy_production_today_remaining": {
        "name": "Hinnanguline energiatoodang – tänaseks jäänud"
      },
      "energy_production_tomorrow": {
        "name": "Hinnanguline energiatoodang – homme"
      },
      "power_highest_peak_time_today": {
        "name": "Suurim võimsuse tippaeg – täna"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Suurim võimsuse tippaeg – homme"
      },
      "power_production_next_12hours": {
        "name": "Eeldatav elektritoodang – järgmised 12 tundi"
      },
      "power_production_next_24hours": {
        "name": "Hinnanguline energiatoodang – järgmised 24 tundi"
      },
      "power_production_next_hour": {
        "name": "Hinnanguline elektritoodang – järgmine tund"
      },
      "power_production_now": {
        "name": "Hinnanguline elektritoodang – praegu"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Kehtetu API võti"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "API võti",
          "azimuth": "Asimuut (360 kraadi, 0 = põhi, 90 = ida, 180 = lõuna, 270 = lääs)",
          "damping": "Summutustegur: reguleerib tulemusi hommikul ja õhtul",
          "damping_evening": "Summutustegur: korrigeerib tulemusi õhtul",
          "damping_morning": "Summutustegur: korrigeerib tulemusi hommikul",
          "declination": "Deklinatsioon (0 = horisontaalne, 90 = vertikaalne)",
          "inverter_size": "Inverteri võimsus (vatti)",
          "modules_power": "Päikesemoodulite koguvõimsus vattides"
        },
        "description": "Need väärtused võimaldavad muuta Solar.Forecast tulemust. Vaata dokumentatsiooni kui see väli on ebaselge."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/fi.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Atsimuutti (360 astetta, 0 = pohjoinen, 90 = itä, 180 = etelä, 270 = länsi)",
          "declination": "Deklinaatio (0 = vaaka, 90 = pystysuuntainen)",
          "latitude": "Leveysaste",
          "longitude": "Pituusaste",
          "modules_power": "Aurinkopaneelien kokonaisteho watteina",
          "name": "Nimi"
        },
        "description": "Täytä aurinkopaneelien tiedot. Katso dokumentaatiosta, jos jokin kenttä on epäselvä."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Arvioitu energiantuotanto - tämä tunti"
      },
      "energy_next_hour": {
        "name": "Arvioitu energiantuotanto - seuraava tunti"
      },
      "energy_production_today": {
        "name": "Arvioitu energiantuotanto - tänään"
      },
      "energy_production_today_remaining": {
        "name": "Arvioitu energiantuotanto - tämän päivän loppuun"
      },
      "energy_production_tomorrow": {
        "name": "Arvioitu energiantuotanto - huomenna"
      },
      "power_highest_peak_time_today": {
        "name": "Suurin tehohuippu - tänään"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Suurin tehohuippu - huomenna"
      },
      "power_production_next_12hours": {
        "name": "Arvioitu sähköntuotanto - seuraavat 12 tuntia"
      },
      "power_production_next_24hours": {
        "name": "Arvioitu sähköntuotanto - seuraavat 24 tuntia"
      },
      "power_production_next_hour": {
        "name": "Arvioitu sähköntuotanto - seuraava tunti"
      },
      "power_production_now": {
        "name": "Arvioitu sähköntuotanto - nyt"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Virheellinen API-avain"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "API-avain",
          "azimuth": "Atsimuutti (360 astetta, 0 = pohjoinen, 90 = itä, 180 = etelä, 270 = länsi)",
          "damping": "Vaimennuskerroin: säätää tuloksia aamulla ja illalla.",
          "damping_evening": "Vaimennuskerroin: säätää tuloksia illalla",
          "damping_morning": "Vaimennuskerroin: säätää tuloksia aamulla",
          "declination": "Deklinaatio (0 = vaaka, 90 = pystysuuntainen)",
          "inverter_size": "Invertterin koko (W)",
          "modules_power": "Aurinkopaneelien kokonaisteho watteina"
        },
        "description": "Nämä arvot mahdollistavat Forecast.Solar-tuloksen säätämisen. Katso dokumentaatiosta, jos jokin kenttä on epäselvä."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/fr.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimut (360 degrés, 0 = Nord, 90 = Est, 180 = Sud, 270 = Ouest)",
          "declination": "Déclinaison (0 = horizontale, 90 = verticale)",
          "latitude": "Latitude",
          "longitude": "Longitude",
          "modules_power": "Puissance de crête totale en watts de vos modules solaires",
          "name": "Nom"
        },
        "description": "Remplissez les données de vos panneaux solaires. Veuillez vous référer à la documentation si un champ n'est pas clair."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Production d'énergie estimée - cette heure"
      },
      "energy_next_hour": {
        "name": "Production d'énergie estimée - heure suivante"
      },
      "energy_production_today": {
        "name": "Production d'énergie estimée - aujourd'hui"
      },
      "energy_production_today_remaining": {
        "name": "Production d'énergie estimée - restante aujourd'hui"
      },
      "energy_production_tomorrow": {
        "name": "Estimation de la production d'énergie - demain"
      },
      "power_highest_peak_time_today": {
        "name": "Heure de pointe de puissance la plus élevée - aujourd'hui"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Heure de pointe de puissance la plus élevée - demain"
      },
      "power_production_next_12hours": {
        "name": "Production d'électricité estimée - 12 prochaines heures"
      },
      "power_production_next_24hours": {
        "name": "Production d'électricité estimée - prochaines 24 heures"
      },
      "power_production_next_hour": {
        "name": "Production d'électricité estimée - heure suivante"
      },
      "power_production_now": {
        "name": "Production d'électricité estimée - maintenant"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Clé d'API non valide"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "Clé d'API",
          "azimuth": "Azimut (360 degrés, 0 = Nord, 90 = Est, 180 = Sud, 270 = Ouest)",
          "damping": "Facteur d'amortissement : ajuste les résultats matin et soir",
          "damping_evening": "Facteur d'amortissement : ajuste les résultats le soir",
          "damping_morning": "Facteur d'amortissement : ajuste les résultats le matin",
          "declination": "Déclinaison (0 = horizontale, 90 = verticale)",
          "inverter_size": "Taille de l'onduleur (en watts)",
          "modules_power": "Puissance de crête totale en watts de vos modules solaires"
        },
        "description": "Ces valeurs permettent de peaufiner le résultat Forecast.Solar. Veuillez vous référer à la documentation si un champ n'est pas clair."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/gsw.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimut (360 grad, 0=Nord, 90=Ost, 180=Süd, 270=West)",
          "declination": "Deklination (0=horizontau, 90=vertikau)",
          "latitude": "Breitegrad",
          "longitude": "Längegrad",
          "modules_power": "Totau Wattspitze vo dine Solarmodul (Watt peak)",
          "name": "Name"
        },
        "description": "Füu d Date vo dine Solarpanel yy. Lueg ir Dokumentation nache, we der es Fäud unklar isch."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Gschetzty Energieproduktion - die Stund"
      },
      "energy_next_hour": {
        "name": "Gschetzty Energieproduktion - nächst Stund"
      },
      "energy_production_today": {
        "name": "Gschetzty Energieproduktion - hüt"
      },
      "energy_production_today_remaining": {
        "name": "Gschetzty Energieproduktion - vo itz bis am Aabe"
      },
      "energy_production_tomorrow": {
        "name": "Gschetzty Energieproduktion - morn"
      },
      "power_highest_peak_time_today": {
        "name": "Höchsti Leistig - hüt"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Höchsti Leistig - morn"
      },
      "power_production_next_12hours": {
        "name": "Gschetzty Stromproduktion - i de nächste 12 Stund"
      },
      "power_production_next_24hours": {
        "name": "Gschetzty Stromproduktion - i de nächste 24 Stund"
      },
      "power_production_next_hour": {
        "name": "Gschetzty Stromproduktion - nächst Stund"
      },
      "power_production_now": {
        "name": "Gschetzty Stromproduktion - itze"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Ungüutige API-Schlüssu"
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/he.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "latitude": "קו רוחב",
          "longitude": "קו אורך",
          "name": "שם"
        }
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "מפתח API לא חוקי"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "מפתח API"
        }
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/hi.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "modules_power": "आपके सौर मॉड्यूल की कुल वाट पीक पावर"
        }
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/hu.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimut (360 fok, 0 = észak, 90 = kelet, 180 = dél, 270 = nyugat)",
          "declination": "Elhajlás (0 = vízszintes, 90 = függőleges)",
          "latitude": "Szélesség",
          "longitude": "Hosszúság",
          "modules power": "A napelemmodulok teljes Watt csúcsteljesítménye",
          "modules_power": "A napelemmodulok teljes Watt csúcsteljesítménye",
          "name": "Elnevezés"
        },
        "description": "Töltse ki a napelemek adatait. Kérem, olvassa el a dokumentációt, ha egy mező nem egyértelmű."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Becsült energia termelés - ebben az órában"
      },
      "energy_next_hour": {
        "name": "Becsült energia termelés - következő órában"
      },
      "energy_production_today": {
        "name": "Becsült energia termelés - ma"
      },
      "energy_production_today_remaining": {
        "name": "Becsült energia termelés - a mai napra még hátralévő"
      },
      "energy_production_tomorrow": {
        "name": "Becsült energia termelés - holnap"
      },
      "power_highest_peak_time_today": {
        "name": "Legnagyobb teljesítmény csúcsidő - ma"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Legnagyobb teljesítmény csúcsidő - holnap"
      },
      "power_production_next_12hours": {
        "name": "Becsült energia termelés - következő 12 óra"
      },
      "power_production_next_24hours": {
        "name": "Becsült energia termelés - következő 24 óra"
      },
      "power_production_next_hour": {
        "name": "Becsült energia termelés - következő óra"
      },
      "power_production_now": {
        "name": "Becsült energia termelés - most"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Érvénytelen API kulcs"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "API kulcs",
          "azimuth": "Azimut (360 fok, 0 = észak, 90 = kelet, 180 = dél, 270 = nyugat)",
          "damping": "Csillapítási tényező: beállítja az eredményeket reggelre és estére",
          "damping_evening": "Csillapítási tényező: korrigálja az esti eredményeket",
          "damping_morning": "Csillapítási tényező: korrigálja a reggeli eredményeket",
          "declination": "Elhajlás (0 = vízszintes, 90 = függőleges)",
          "inverter_size": "Inverter teljesítménye (Watt)",
          "modules power": "A napelemmodulok teljes Watt csúcsteljesítménye",
          "modules_power": "A napelemmodulok teljes Watt csúcsteljesítménye"
        },
        "description": "Ezek az értékek lehetővé teszik a Forecast.Solar eredményének finomhangolását. Ha egy mező nem egyértelmű, kérem, olvassa el a dokumentációt."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/id.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimuth (360 derajat, 0 = Utara, 90 = Timur, 180 = Selatan, 270 = Barat)",
          "declination": "Deklinasi (0 = Horizontal, 90 = Vertikal)",
          "latitude": "Lintang",
          "longitude": "Bujur",
          "modules power": "Total daya puncak modul surya Anda dalam Watt",
          "modules_power": "Total daya puncak modul surya Anda dalam Watt",
          "name": "Nama"
        },
        "description": "Isi data panel surya Anda. Rujuk ke dokumentasi jika bidang isian tidak jelas."
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Kunci API tidak valid"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "Kunci API",
          "azimuth": "Azimuth (360 derajat, 0 = Utara, 90 = Timur, 180 = Selatan, 270 = Barat)",
          "damping": "Faktor redaman: menyesuaikan hasil di pagi dan sore hari",
          "declination": "Deklinasi (0 = Horizontal, 90 = Vertikal)",
          "inverter_size": "Ukuran inverter (Watt)",
          "modules power": "Total daya puncak modul surya Anda dalam Watt",
          "modules_power": "Total daya puncak modul surya Anda dalam Watt"
        },
        "description": "Nilai-nilai ini memungkinkan penyesuaian hasil Forecast.Solar. Rujuk ke dokumentasi jika bidang isian tidak jelas."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/it.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimut (360 gradi, 0 = Nord, 90 = Est, 180 = Sud, 270 = Ovest)",
          "declination": "Declinazione (0 = Orizzontale, 90 = Verticale)",
          "latitude": "Latitudine",
          "longitude": "Logitudine",
          "modules power": "Potenza di picco totale in Watt dei tuoi moduli solari",
          "modules_power": "Picco totale di potenza dei tuoi moduli solari",
          "name": "Nome"
        },
        "description": "Compila i dati dei tuoi pannelli solari. Fare riferimento alla documentazione se un campo non è chiaro."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Produzione di energia stimata - quest'ora"
      },
      "energy_next_hour": {
        "name": "Produzione di energia stimata - ora successiva"
      },
      "energy_production_today": {
        "name": "Produzione di energia stimata - oggi"
      },
      "energy_production_today_remaining": {
        "name": "Produzione di energia stimata - rimanente oggi"
      },
      "energy_production_tomorrow": {
        "name": "Produzione di energia stimata - domani"
      },
      "power_highest_peak_time_today": {
        "name": "Ora di picco di massima potenza - oggi"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Ora di picco di massima potenza - domani"
      },
      "power_production_next_12hours": {
        "name": "Produzione di potenza stimata - prossime 12 ore"
      },
      "power_production_next_24hours": {
        "name": "Produzione di potenza stimata - prossime 24 ore"
      },
      "power_production_next_hour": {
        "name": "Produzione di potenza stimata - ora successiva"
      },
      "power_production_now": {
        "name": "Produzione di potenza stimata - ora"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Chiave API non valida"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "Chiave API",
          "azimuth": "Azimut (360 gradi, 0 = Nord, 90 = Est, 180 = Sud, 270 = Ovest)",
          "damping": "Fattore di smorzamento: regola i risultati al mattino e alla sera",
          "damping_evening": "Fattore di smorzamento: regola i risultati la sera",
          "damping_morning": "Fattore di smorzamento: regola i risultati al mattino",
          "declination": "Declinazione (0 = Orizzontale, 90 = Verticale)",
          "inverter_size": "Dimensioni inverter (Watt)",
          "modules power": "Potenza di picco totale in Watt dei tuoi moduli solari",
          "modules_power": "Picco totale di potenza dei tuoi moduli solari"
        },
        "description": "Questi valori consentono di modificare il risultato di Forecast.Solar. Se un campo non è chiaro, consultare la documentazione."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/ja.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "方位角(360度、0=北、90=東、180=南、270=西)",
          "declination": "偏角(0＝水平、90＝垂直)",
          "latitude": "緯度",
          "longitude": "経度",
          "modules power": "ソーラーモジュールの総ワットピーク電力",
          "modules_power": "ソーラーモジュールの総ワットピーク電力",
          "name": "名前"
        },
        "description": "ソーラーパネルのデータを入力してください。不明な場合は、ドキュメントを参照してください。"
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "推定エネルギー生産量 - この時間"
      },
      "energy_next_hour": {
        "name": "推定エネルギー生産量 - 今後 1 時間"
      },
      "energy_production_today": {
        "name": "推定エネルギー生産量 - 今日"
      },
      "energy_production_today_remaining": {
        "name": "推定エネルギー生産量 - 今日の残り"
      },
      "energy_production_tomorrow": {
        "name": "推定エネルギー生産量 - 明日"
      },
      "power_highest_peak_time_today": {
        "name": "最高電力ピーク時間 - 今日"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "最高電力ピーク時間 - 明日"
      },
      "power_production_next_12hours": {
        "name": "推定発電量 - 今後 12 時間"
      },
      "power_production_next_24hours": {
        "name": "推定発電量 - 今後 24 時間"
      },
      "power_production_next_hour": {
        "name": "推定発電量 - 今後 1 時間"
      },
      "power_production_now": {
        "name": "推定発電量 - 今"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "無効なAPIキー"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "APIキー",
          "azimuth": "方位角(360度、0=北、90=東、180=南、270=西)",
          "damping": "減衰係数(ダンピングファクター): 朝と夕方の結果を調整する",
          "damping_evening": "ダンピングファクター：夕方の結果を調整する。",
          "damping_morning": "ダンピングファクター：朝の結果を調整する。",
          "declination": "偏角(0＝水平、90＝垂直)",
          "inverter_size": "インバーターのサイズ（ワット）",
          "modules power": "ソーラーモジュールの総ワットピーク電力",
          "modules_power": "ソーラーモジュールの総ワットピーク電力"
        },
        "description": "これらの値により、Forecast.Solar の結果を微調整できます。フィールドが不明な場合は、ドキュメントを参照してください。"
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/ko.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "방위각(360도, 0 = 북쪽, 90 = 동쪽, 180 = 남쪽, 270 = 서쪽)",
          "declination": "편각(0 = 수평, 90 = 수직)",
          "latitude": "위도",
          "longitude": "경도",
          "modules power": "태양광 모듈의 총 와트 피크 전력",
          "modules_power": "태양광 모듈의 총 와트 피크 전력",
          "name": "이름"
        },
        "description": "태양광 패널의 데이터를 입력합니다. 필드가 명확하지 않은 경우 설명서를 참조하십시오."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "예상 에너지 생산량 - 이 시간"
      },
      "energy_next_hour": {
        "name": "예상 에너지 생산량 - 다음 시간"
      },
      "energy_production_today": {
        "name": "예상 에너지 생산량 - 오늘"
      },
      "energy_production_today_remaining": {
        "name": "예상 에너지 생산량 - 오늘 남은 시간"
      },
      "energy_production_tomorrow": {
        "name": "예상 에너지 생산량 - 내일"
      },
      "power_highest_peak_time_today": {
        "name": "최고 전력 피크 시간 - 오늘"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "최고 전력 피크 시간 - 내일"
      },
      "power_production_next_12hours": {
        "name": "예상 전력 생산량 - 다음 12시간"
      },
      "power_production_next_24hours": {
        "name": "예상 전력 생산량 - 다음 24시간"
      },
      "power_production_next_hour": {
        "name": "예상 전력 생산량 - 다음 시간"
      },
      "power_production_now": {
        "name": "예상 전력 생산량 - 지금"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "API 키가 잘못되었습니다"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "API 키",
          "azimuth": "방위각(360도, 0 = 북쪽, 90 = 동쪽, 180 = 남쪽, 270 = 서쪽)",
          "damping": "댐핑 팩터: 아침과 저녁에 결과를 조정합니다.",
          "damping_evening": "댐핑 팩터: 저녁에 결과를 조정합니다.",
          "damping_morning": "댐핑 팩터: 아침에 결과를 조정합니다.",
          "declination": "편각(0 = 수평, 90 = 수직)",
          "inverter_size": "인버터 크기(와트)",
          "modules power": "태양광 모듈의 총 와트 피크 전력",
          "modules_power": "태양광 모듈의 총 와트 피크 전력"
        },
        "description": "이 값을 사용하면 Forecast.Solar 결과를 조정할 수 있습니다. 필드가 명확하지 않은 경우 설명서를 참조하십시오."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/lt.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimutas (360 laipsnių, 0 = šiaurė, 90 = rytai, 180 = pietai, 270 = vakarai)",
          "declination": "Deklinacija (0 = horizontali, 90 = vertikali)",
          "latitude": "Platuma",
          "longitude": "Ilguma",
          "modules power": "Bendra jūsų saulės modulių didžiausia galia vatais",
          "modules_power": "Bendra jūsų saulės modulių didžiausia galia vatais",
          "name": "Vardas"
        },
        "description": "Užpildykite savo saulės kolektorių duomenis. Jei laukas neaiškus, žr. dokumentaciją."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Apskaičiuota energijos gamyba – šią valandą"
      },
      "energy_next_hour": {
        "name": "Numatoma energijos gamyba – kitą valandą"
      },
      "energy_production_today": {
        "name": "Apskaičiuota energijos gamyba – šiandien"
      },
      "energy_production_today_remaining": {
        "name": "Apskaičiuota energijos gamyba – likusi šiandien"
      },
      "energy_production_tomorrow": {
        "name": "Numatoma energijos gamyba – rytoj"
      },
      "power_highest_peak_time_today": {
        "name": "Didžiausios galios piko laikas – šiandien"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Didžiausios galios piko laikas – rytoj"
      },
      "power_production_next_12hours": {
        "name": "Numatoma elektros energijos gamyba – ateinančios 12 valandų"
      },
      "power_production_next_24hours": {
        "name": "Numatoma elektros energijos gamyba – artimiausias 24 valandas"
      },
      "power_production_next_hour": {
        "name": "Numatoma elektros energijos gamyba – kitą valandą"
      },
      "power_production_now": {
        "name": "Numatoma energijos gamyba – dabar"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Neteisingas API raktas"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "API raktas",
          "azimuth": "Azimutas (360 laipsnių, 0 = šiaurė, 90 = rytai, 180 = pietai, 270 = vakarai)",
          "damping": "Slopinimo koeficientas: koreguoja rezultatus ryte ir vakare",
          "damping_evening": "Slopinimo koeficientas: koreguoja rezultatus vakare",
          "damping_morning": "Slopinimo koeficientas: koreguoja rezultatus ryte",
          "declination": "Deklinacija (0 = horizontali, 90 = vertikali)",
          "inverter_size": "Inverterio dydis (vatai)",
          "modules power": "Bendra jūsų saulės modulių didžiausia galia vatais",
          "modules_power": "Bendra jūsų saulės modulių didžiausia galia vatais"
        },
        "description": "Šios vertės leidžia koreguoti prognozę. Saulės rezultatas. Jei laukas neaiškus, žr. dokumentaciją."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/lv.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "longitude": "Garums"
        }
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/nb.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimut (360 grader, 0 = Nord, 90 = Øst, 180 = Sør, 270 = Vest)",
          "declination": "Deklinasjon (0 = horisontal, 90 = vertikal)",
          "latitude": "Breddegrad",
          "longitude": "Lengdegrad",
          "modules power": "Total Watt-toppeffekt i solcellemodulene dine",
          "name": "Navn"
        },
        "description": "Fyll ut dataene til solcellepanelene. Se dokumentasjonen hvis et felt er uklart."
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Ugyldig API-nøkkel"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "API-nøkkel",
          "damping": "Dempingsfaktor: justerer resultatene om morgenen og kvelden",
          "inverter_size": "Inverterstørrelse (Watt)"
        },
        "description": "Disse verdiene gjør det mulig å justere Forecast.Solar-resultatet. Vennligst se dokumentasjonen hvis et felt er uklart."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/nl.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimut (360 graden, 0 = Noord, 90 = Oost, 180 = Zuid, 270 = West)",
          "declination": "Declinatie (0 = Horizontaal, 90 = Verticaal)",
          "latitude": "Breedtegraad",
          "longitude": "Lengtegraad",
          "modules power": "Totaal Watt piekvermogen van je zonnepanelen",
          "modules_power": "Totaal Watt piekvermogen van je zonnepanelen",
          "name": "Naam"
        },
        "description": "Vul de gegevens van je zonnepanelen in. Raadpleeg de documentatie als een veld niet duidelijk is."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Geschatte energieproductie - dit uur"
      },
      "energy_next_hour": {
        "name": "Geschatte energieproductie - volgend uur"
      },
      "energy_production_today": {
        "name": "Geschatte energieproductie - vandaag"
      },
      "energy_production_today_remaining": {
        "name": "Geschatte energieproductie - resterend vandaag"
      },
      "energy_production_tomorrow": {
        "name": "Geschatte energieproductie - morgen"
      },
      "power_highest_peak_time_today": {
        "name": "Hoogste vermogenspiek tijd - vandaag"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Hoogste vermogenspiek tijd - morgen"
      },
      "power_production_next_12hours": {
        "name": "Geschatte energieproductie - volgende 12 uur"
      },
      "power_production_next_24hours": {
        "name": "Geschatte energieproductie - volgende 24 uur"
      },
      "power_production_next_hour": {
        "name": "Geschatte energieproductie - volgend uur"
      },
      "power_production_now": {
        "name": "Geschatte energieproductie - nu"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Ongeldige API-sleutel"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "API-sleutel",
          "azimuth": "Azimut (360 graden, 0 = Noord, 90 = Oost, 180 = Zuid, 270 = West)",
          "damping": "Dempingsfactor: past de resultaten 's ochtends en 's avonds aan",
          "damping_evening": "Dempingsfactor: pas de resultaten aan in de avond",
          "damping_morning": "Dempingsfactor: pas de resultaten aan in de morgen",
          "declination": "Declinatie (0 = Horizontaal, 90 = Verticaal)",
          "inverter_size": "Omvormer grootte (Watt)",
          "modules power": "Totaal Watt piekvermogen van je zonnepanelen",
          "modules_power": "Totaal Watt piekvermogen van je zonnepanelen"
        }
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/pl.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azymut (360 stopni, 0 = Północ, 90 = Wschód, 180 = Południe, 270 = Zachód)",
          "declination": "Deklinacja (0 = Poziomo, 90 = Pionowo)",
          "latitude": "Szerokość geograficzna",
          "longitude": "Długość geograficzna",
          "modules power": "Całkowita moc szczytowa modułów fotowoltaicznych w watach",
          "modules_power": "Całkowita moc szczytowa modułów fotowoltaicznych w watach",
          "name": "Nazwa"
        },
        "description": "Wpisz dane swoich paneli słonecznych. Proszę zapoznać się z dokumentacją, jeśli pole jest niejasne."
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Nieprawidłowy klucz API"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "Klucz API",
          "azimuth": "Azymut (360 stopni, 0 = Północ, 90 = Wschód, 180 = Południe, 270 = Zachód)",
          "damping": "Współczynnik tłumienia: dostosowuje wyniki rano i wieczorem",
          "declination": "Deklinacja (0 = Poziomo, 90 = Pionowo)",
          "inverter_size": "Rozmiar falownika (Wat)",
          "modules power": "Całkowita moc szczytowa modułów fotowoltaicznych w watach",
          "modules_power": "Całkowita moc szczytowa modułów fotowoltaicznych w watach"
        },
        "description": "Te wartości pozwalają dostosować wyniki dla Forecast.Solar. Proszę zapoznać się z dokumentacją, jeśli pole jest niejasne."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/pt-BR.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimute (360º, 0º = Norte, 90º = Leste, 180º = Sul, 270º = Oeste)",
          "declination": "Declinação (0 = Horizontal, 90 = Vertical)",
          "latitude": "Latitude",
          "longitude": "Longitude",
          "modules power": "Potência de pico total em Watts de seus módulos solares",
          "modules_power": "Potência de pico total em Watts de seus módulos solares",
          "name": "Nome"
        },
        "description": "Esses valores permitem ajustar o resultado do Forecast.Solar. Consulte a documentação se um campo não estiver claro."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Produção de energia estimada - esta hora"
      },
      "energy_next_hour": {
        "name": "Produção de energia estimada - próxima hora"
      },
      "energy_production_today": {
        "name": "Produção de energia estimada - hoje"
      },
      "energy_production_today_remaining": {
        "name": "Produção de energia estimada - restante hoje"
      },
      "energy_production_tomorrow": {
        "name": "Produção de energia estimada - amanhã"
      },
      "power_highest_peak_time_today": {
        "name": "Horário de pico de maior potência - hoje"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Horário de pico de maior potência - amanhã"
      },
      "power_production_next_12hours": {
        "name": "Produção de energia estimada - próximas 12 horas"
      },
      "power_production_next_24hours": {
        "name": "Produção de energia estimada - próximas 24 horas"
      },
      "power_production_next_hour": {
        "name": "Produção de energia estimada - próxima hora"
      },
      "power_production_now": {
        "name": "Produção de energia estimada - agora"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Chave de API inválida"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "Chave da API",
          "azimuth": "Azimute (360º, 0º = Norte, 90º = Leste, 180º = Sul, 270º = Oeste)",
          "damping": "Fator de amortecimento: ajusta os resultados de manhã e à noite",
          "declination": "Declinação (0 = Horizontal, 90 = Vertical)",
          "inverter_size": "Potência do inversor (Watt)",
          "modules power": "Potência de pico total em Watts de seus módulos solares",
          "modules_power": "Potência de pico total em Watts de seus módulos solares"
        },
        "description": "Esses valores permitem ajustar o resultado do Forecast.Solar. Consulte a documentação se um campo não estiver claro."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/pt.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimute (360 graus, 0 = Norte, 90 = Este, 180 = Sul, 270 = Oeste)",
          "declination": "Declive (0 = Horizontal, 90 = Vertical)",
          "latitude": "Latitude",
          "longitude": "Longitude",
          "modules power": "Potência de pico total em watts dos seus módulos solares",
          "name": "Nome"
        },
        "description": "Preencha os dados dos seus painéis solares. Consulte a documentação se algum campo não for claro."
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Chave de API inválida"
    },
    "step": {
      "init": {
        "data": {
          "azimuth": "Azimute (360 graus, 0 = Norte, 90 = Este, 180 = Sul, 270 = Oeste)",
          "damping": "Fator de amortecimento: ajusta os resultados de manhã e à noite",
          "declination": "Declive (0 = Horizontal, 90 = Vertical)",
          "inverter_size": "Tamanho do inversor (Watt)"
        },
        "description": "Estes valores permitem ajustar o resultado do Forecast.Solar. Consulte a documentação se um campo não for claro."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/ro.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimut (360 de grade, 0 = Nord, 90 = Est, 180 = Sud, 270 = Vest)",
          "declination": "Declinație (0 = Orizontal, 90 = Vertical)",
          "latitude": "Latitudine",
          "longitude": "Longitudine",
          "modules power": "Puterea totală de vârf a modulelor tale solare, în Watti",
          "name": "Nume"
        },
        "description": "Completează datele panourilor solare. Te rugăm să consulți documentația dacă vreun câmp este neclar."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Producția estimată de energie - această oră"
      },
      "energy_next_hour": {
        "name": "Producția estimată de energie - următoarea oră"
      },
      "energy_production_today": {
        "name": "Producția estimată de energie - astăzi"
      },
      "energy_production_today_remaining": {
        "name": "Producția estimată de energie - rămasă astăzi"
      },
      "energy_production_tomorrow": {
        "name": "Producția estimată de energie - mâine"
      },
      "power_highest_peak_time_today": {
        "name": "Ora vârfului de putere maxim - astăzi"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Ora vârfului de putere maxim - mâine"
      },
      "power_production_next_12hours": {
        "name": "Producția estimată de energie - următoarele 12 ore"
      },
      "power_production_next_24hours": {
        "name": "Producția estimată de energie - următoarele 24 de ore"
      },
      "power_production_next_hour": {
        "name": "Producția estimată de energie - următoarea oră"
      },
      "power_production_now": {
        "name": "Producția estimată de energie - acum"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Cheie API nevalidă"
    },
    "step": {
      "init": {
        "data": {
          "damping": "Factor de atenuare: ajustează rezultatele dimineața și seara",
          "inverter_size": "Dimensiune invertor (Watt)"
        },
        "description": "Aceste valori permit ajustarea rezultatului Forecast.Solar. Te rugăm să consulți documentația daca vreun câmp este neclar."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/ru.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Азимут (360 градусов, 0 = север, 90 = восток, 180 = юг, 270 = запад)",
          "declination": "Склонение (0 = горизонтальное, 90 = вертикальное)",
          "latitude": "Широта",
          "longitude": "Долгота",
          "modules power": "Общая пиковая мощность Ваших солнечных модулей (в Ваттах)",
          "modules_power": "Общая пиковая мощность Ваших солнечных модулей (в Ваттах)",
          "name": "Название"
        },
        "description": "Настройка Home Assistant для интеграции с Forecast.Solar."
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Неверный ключ API"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "Ключ API",
          "azimuth": "Азимут (360 градусов, 0 = север, 90 = восток, 180 = юг, 270 = запад)",
          "damping": "Фактор затухания: корректирует результаты утром и вечером",
          "declination": "Склонение (0 = горизонтальное, 90 = вертикальное)",
          "inverter_size": "Мощность инвертора (в Ваттах)",
          "modules power": "Общая пиковая мощность Ваших солнечных модулей (в Ваттах)"
        },
        "description": "Настройки интеграции Forecast.Solar."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/sk.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimut (360˚, 0 = sever, 90 = východ, 180 = juh, 270 = západ)",
          "declination": "Deklinácia (0 = horizontálna, 90 = vertikálna)",
          "latitude": "Zemepisná šírka",
          "longitude": "Zemepisná dĺžka",
          "modules power": "Celkový špičkový výkon solárnych modulov",
          "modules_power": "Celkový špičkový výkon solárnych modulov",
          "name": "Názov"
        },
        "description": "Vyplňte údaje o svojich solárnych paneloch. Ak je niektoré pole nejasné, pozrite si dokumentáciu."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Odhadovaná výroba energie - táto hodina"
      },
      "energy_next_hour": {
        "name": "Odhadovaná výroba energie - nasledujúca hodina"
      },
      "energy_production_today": {
        "name": "Odhadovaná výroba energie - dnes"
      },
      "energy_production_today_remaining": {
        "name": "Odhadovaná výroba energie - zostávajúca dnes"
      },
      "energy_production_tomorrow": {
        "name": "Odhadovaná výroba energie - zajtra"
      },
      "power_highest_peak_time_today": {
        "name": "Najvyšší výkon v čase špičky - dnes"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Čas najvyššieho výkonu - zajtra"
      },
      "power_production_next_12hours": {
        "name": "Odhadovaná výroba energie - nasledujúcich 12 hodín"
      },
      "power_production_next_24hours": {
        "name": "Odhadovaná výroba energie - nasledujúcich 24 hodín"
      },
      "power_production_next_hour": {
        "name": "Odhadovaná výroba energie - nasledujúca hodina"
      },
      "power_production_now": {
        "name": "Odhadovaná výroba energie - teraz"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Neplatný API kľúč"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "API kľúč",
          "azimuth": "Azimut (360˚, 0 = sever, 90 = východ, 180 = juh, 270 = západ)",
          "damping": "Činiteľ tlmenia: upravuje výsledky ráno a večer",
          "damping_evening": "Tlmiaci faktor: upravuje výsledky vo večerných hodinách",
          "damping_morning": "Tlmiaci faktor: upravuje výsledky ráno",
          "declination": "Deklinácia (0 = horizontálna, 90 = vertikálna)",
          "inverter_size": "Veľkosť meniča (Watt)",
          "modules power": "Celkový špičkový výkon solárnych modulov",
          "modules_power": "Celkový špičkový výkon solárnych modulov"
        },
        "description": "Tieto hodnoty umožňujú upraviť výsledné hodnoty Solar.Forecast. Ak je niektoré pole nejasné, pozrite si dokumentáciu."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/sl.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimut (360 stopinj, 0 = sever, 90 = vzhod, 180 = jug, 270 = zahod)",
          "declination": "Odstopanja (0 = vodoravno, 90 = navpično)",
          "latitude": "Zemljepisna širina",
          "longitude": "Zemljepisna dolžina",
          "modules power": "Skupna konična moč v vatih vaših solarnih modulov",
          "name": "Naziv"
        },
        "description": "Vnesite podatke o svojih sončnih kolektorjih. Če vam podatek ni jasen, si oglejte dokumentacijo."
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Neveljaven API ključ"
    },
    "step": {
      "init": {
        "data": {
          "damping": "Dušilni faktor: prilagoditev rezultatov zjutraj in zvečer",
          "inverter_size": "Velikost pretvornika (Watt)"
        },
        "description": "Te vrednosti omogočajo prilagoditev rezultata Forecast.Solar. Če vam podatek ni jasen, si oglejte dokumentacijo."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/sv.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimuth (360 grader, 0 = norr, 90 = öst, 180 = söder, 270 = väster)",
          "declination": "Deklination (0 = horisontell, 90 = vertikal)",
          "latitude": "Latitud",
          "longitude": "Longitud",
          "modules power": "Total maxeffekt (Watt) på dina solpaneler",
          "modules_power": "Total maxeffekt (Watt) på dina solpaneler",
          "name": "Namn"
        },
        "description": "Fyll i data för dina solpaneler. Se dokumentationen om ett fält är otydligt."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Beräknad elproduktion - denna timme"
      },
      "energy_next_hour": {
        "name": "Beräknad elproduktion - nästa timme"
      },
      "energy_production_today": {
        "name": "Beräknad elproduktion - idag"
      },
      "energy_production_today_remaining": {
        "name": "Beräknad elproduktion - kvar idag"
      },
      "energy_production_tomorrow": {
        "name": "Beräknad elproduktion - imorgon"
      },
      "power_highest_peak_time_today": {
        "name": "Tidpunkt för högsta effekttopp - idag"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "Tidpunkt för högsta effekttopp - imorgon"
      },
      "power_production_next_12hours": {
        "name": "Beräknad effektproduktion - nästa 12 timmar"
      },
      "power_production_next_24hours": {
        "name": "Beräknad effektproduktion - nästa 24 timmar"
      },
      "power_production_next_hour": {
        "name": "Beräknad effektproduktion - nästa timme"
      },
      "power_production_now": {
        "name": "Beräknad effektproduktion - nu"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Ogiltig API-nyckel"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "API-nyckel",
          "azimuth": "Azimuth (360 grader, 0 = norr, 90 = öst, 180 = söder, 270 = väster)",
          "damping": "Dämpningsfaktor: justerar resultaten på morgonen och kvällen",
          "damping_evening": "Dämpningsfaktor: justerar resultatet på kvällen",
          "damping_morning": "Dämpningsfaktor: justerar resultaten på morgonen",
          "declination": "Deklination (0 = horisontell, 90 = vertikal)",
          "inverter_size": "Växelriktarens storlek (Watt)",
          "modules power": "Total maxeffekt (Watt) på dina solpaneler",
          "modules_power": "Total maxeffekt (Watt) på dina solpaneler"
        },
        "description": "Dessa värden tillåter justering av Solar.Forecast-resultatet. Se dokumentationen om ett fält är otydligt."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/tr.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Azimut (360 derece, 0 = Kuzey, 90 = Doğu, 180 = Güney, 270 = Batı)",
          "declination": "Sapma (0 = Yatay, 90 = Dikey)",
          "latitude": "Enlem",
          "longitude": "Boylam",
          "modules power": "Solar modüllerinizin toplam en yüksek Watt gücü",
          "modules_power": "Solar modüllerinizin toplam en yüksek Watt gücü",
          "name": "Ad"
        },
        "description": "Güneş panellerinizin verilerini doldurun. Bir alan net değilse lütfen belgelere bakın."
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "Tahmini enerji üretimi - bu saat"
      },
      "energy_next_hour": {
        "name": "Tahmini enerji üretimi - sonraki saat"
      },
      "energy_production_today": {
        "name": "Tahmini enerji üretimi - bugün"
      },
      "energy_production_today_remaining": {
        "name": "Tahmini enerji üretimi - bugün kalan"
      },
      "energy_production_tomorrow": {
        "name": "Tahmini enerji üretimi - yarın"
      },
      "power_highest_peak_time_today": {
        "name": "En yüksek güç zirve zamanı - bugün"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "En yüksek güç tepe zamanı - yarın"
      },
      "power_production_next_12hours": {
        "name": "Tahmini güç üretimi - sonraki 12 saat"
      },
      "power_production_next_24hours": {
        "name": "Tahmini güç üretimi - sonraki 24 saat"
      },
      "power_production_next_hour": {
        "name": "Tahmini güç üretimi - sonraki saat"
      },
      "power_production_now": {
        "name": "Tahmini güç üretimi - şimdi"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Geçersiz API anahtarı"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "API Anahtarı",
          "azimuth": "Azimut (360 derece, 0 = Kuzey, 90 = Doğu, 180 = Güney, 270 = Batı)",
          "damping": "Sönümleme faktörü: sonuçları sabah ve akşam ayarlar",
          "damping_evening": "Sönümleme faktörü: akşam sonuçları ayarlar",
          "damping_morning": "Sönümleme faktörü: sabah sonuçları ayarlar",
          "declination": "Sapma (0 = Yatay, 90 = Dikey)",
          "inverter_size": "İnverter boyutu (Watt)",
          "modules power": "Solar modüllerinizin toplam en yüksek Watt gücü",
          "modules_power": "Solar modüllerinizin toplam en yüksek Watt gücü"
        },
        "description": "Bu değerler, Forecast.Solar sonucunun değiştirilmesine izin verir. Bir alan net değilse lütfen belgelere bakın."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/uk.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "Азимут (360 градусів, 0 = північ, 90 = схід, 180 = південь, 270 = захід)",
          "declination": "Схилення (0 = горизонтальне, 90 = вертикальне)",
          "latitude": "Широта",
          "longitude": "Довгота",
          "modules power": "Загальна пікова потужність ваших сонячних модулів у Ватах",
          "modules_power": "Загальна пікова потужність ваших сонячних модулів у Ватах",
          "name": "Назва"
        },
        "description": "Заповніть дані ваших сонячних панелей. Якщо якесь поле незрозуміле, зверніться до документації."
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "Хибний ключ API"
    },
    "step": {
      "init": {
        "data": {
          "damping": "Фактор демпфування: коригує результати вранці та ввечері",
          "inverter_size": "Потужність інвертора (Вт)"
        },
        "description": "Ці значення дозволяють налаштувати результат Forecast.Solar. Будь ласка, зверніться до документації, якщо якесь поле незрозуміле."
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/zh-Hans.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "方位角（360 度，以 0 为北，90 为东，180 为南，270 为西）",
          "declination": "倾斜（以 0 为水平，90 为垂直）",
          "latitude": "纬度",
          "longitude": "经度",
          "modules power": "光伏发电模组的总峰值功率(W)",
          "modules_power": "您的太阳能模块的总瓦特峰值功率",
          "name": "名称"
        },
        "description": "请填写您的太阳能板的参数。对于不清楚的字段，请参阅有关文档。"
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "预计发电量 - 本小时"
      },
      "energy_next_hour": {
        "name": "预计发电量 - 下一小时"
      },
      "energy_production_today": {
        "name": "预计能源产量 - 今天"
      },
      "energy_production_today_remaining": {
        "name": "预计能源产量 - 今天剩余"
      },
      "energy_production_tomorrow": {
        "name": "预计能源产量 - 明天"
      },
      "power_highest_peak_time_today": {
        "name": "最高功率峰值时间 - 今天"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "最高功率峰值时间 - 明天"
      },
      "power_production_next_12hours": {
        "name": "预计发电量 - 未来 12 小时"
      },
      "power_production_next_24hours": {
        "name": "预计发电量 - 未来 24 小时"
      },
      "power_production_next_hour": {
        "name": "预计发电量 - 下一小时"
      },
      "power_production_now": {
        "name": "预计发电量 - 现在"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "API 密钥无效"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "API 密钥",
          "azimuth": "方位角（360 度，以 0 为北，90 为东，180 为南，270 为西）",
          "damping": "阻尼系数：调节早间和晚间的结果",
          "damping_evening": "阻尼系数：调节晚间的结果",
          "damping_morning": "阻尼系数：调节早间的结果",
          "declination": "倾斜（以 0 为水平，90 为垂直）",
          "inverter_size": "逆变器尺寸（瓦特）",
          "modules power": "您的太阳能模块的总瓦特峰值功率",
          "modules_power": "您的太阳能模块的总瓦特峰值功率"
        },
        "description": "这些值用于调节 Forecast.Solar 结果。对于不清楚的字段，请参阅文档。"
      }
    }
  }
}


---
# custom_components/ha_sunforecast_plus/translations/zh-Hant.json
---

{
  "config": {
    "step": {
      "user": {
        "data": {
          "azimuth": "方位角（360 度單位。0 = 北、90 = 東、180 = 南、270 = 西）",
          "declination": "偏角（0 = 水平、90 = 垂直）",
          "latitude": "緯度",
          "longitude": "經度",
          "modules power": "太陽能模組總峰值功率",
          "modules_power": "太陽能模組總峰值功率",
          "name": "名稱"
        },
        "description": "填寫太陽能板資料。如果有不清楚的地方，請參考文件說明。"
      }
    }
  },
  "entity": {
    "sensor": {
      "energy_current_hour": {
        "name": "預估能源產量 - 此一小時"
      },
      "energy_next_hour": {
        "name": "預估能源產量 - 下一小時"
      },
      "energy_production_today": {
        "name": "預估能源產量 - 本日"
      },
      "energy_production_today_remaining": {
        "name": "預估能源產量 - 今日剩餘時間"
      },
      "energy_production_tomorrow": {
        "name": "預估能源產量 - 明日"
      },
      "power_highest_peak_time_today": {
        "name": "最高功率峰值時間 - 本日"
      },
      "power_highest_peak_time_tomorrow": {
        "name": "最高功率峰值時間 - 明日"
      },
      "power_production_next_12hours": {
        "name": "預計電力產量 - 未來 12 小時"
      },
      "power_production_next_24hours": {
        "name": "預計電力產量 - 未來 24 小時"
      },
      "power_production_next_hour": {
        "name": "預計電力產量 - 下一小時"
      },
      "power_production_now": {
        "name": "預計電力產量 - 現在"
      }
    }
  },
  "options": {
    "error": {
      "invalid_api_key": "API 金鑰無效"
    },
    "step": {
      "init": {
        "data": {
          "api_key": "API 金鑰",
          "azimuth": "方位角（360 度單位。0 = 北、90 = 東、180 = 南、270 = 西）",
          "damping": "阻尼因素：調整清晨與傍晚結果",
          "damping_evening": "阻尼因素：調整傍晚結果",
          "damping_morning": "阻尼因素：調整清晨結果",
          "declination": "偏角（0 = 水平、90 = 垂直）",
          "inverter_size": "變流器尺寸（Watt）",
          "modules power": "太陽能模組總峰值功率",
          "modules_power": "太陽能模組總峰值功率"
        },
        "description": "此些數值允許微調 Forecast.Solar 結果。如果有不清楚的地方、請參考文件說明。"
      }
    }
  }
}


---
# Estimation du nombre de tokens : 39940 tokens
